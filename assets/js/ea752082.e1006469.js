"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[577],{7464:e=>{e.exports=JSON.parse('{"functions":[],"properties":[],"types":[{"name":"DatatypeInterface<T>","desc":"Eval is a string indicating which evaluator to use for this value if applicable. Extra info can be added regarding this for advanced datatypes.  \\nRead is a function that is passed a ReaderData instance and expected to read the ReaderData and return whatever was passed into Write.\\nWrite is a function that is passed a WriterData instance and a value and is expected to write the value into WriterData.","lua_type":"{Eval: string?, Read: (ReaderData) -> T, Write: (writer: WriterData, value: T) -> ()}","source":{"line":163,"path":"src/types.luau"}}],"name":"Datatype","desc":":::note\\nThis is the Internal documentation for writing custom datatypes. If you were looking for a list of all datatypes, that can be found [**here**](../docs/Datatypes/Primitives)\\n:::\\n\\nInternally, all datatypes follow the DatatypeInterface format.\\n\\nYou can have static datatypes, which require no arguments passed in (most primitives).\\n```lua\\n-- float64.luau\\n\\nlocal Pack = require(path.to.pack)\\nlocal Reader = Pack.Reader\\nlocal Writer = Pack.Writer\\n\\n-- You should freeze the DatatypeInterface table\\nlocal datatype = table.freeze({\\n\\tEval = \\"f64\\",\\n\\tRead = function(reader: Pack.ReaderData): number\\n\\t\\treturn Reader.f64(reader)\\n\\tend,\\n\\tWrite = function(writer: Pack.WriterData, value: number)\\n\\t\\tWriter.alloc(writer, 8)\\n\\t\\tWriter.f64(writer, value)\\n\\tend,\\n}) :: Pack.DatatypeInterface<number>\\n\\n-- For type inference when writing packets, we dont use the \\n-- DatatypeInterface type when returning our datatype module.\\n-- Instead we want to annoate it as the basic type, in this case number.\\nreturn (datatype :: any) :: number\\n```\\n\\nYou can also have dynamic datatypes which require arguments passed in (structural datatypes).\\n```lua\\n-- Array.luau\\n\\nlocal Pack = require(path.to.pack)\\nlocal Reader = Pack.Reader\\nlocal Writer = Pack.Writer\\n\\n-- We return a function where we provide the datatype \\n-- to use for values and return an array datatype for that\\nreturn function<T>(valueType: Pack.DatatypeInterface<T>): Pack.DatatypeInterface<{ T }>\\n\\tlocal read, write = valueType.Read, valueType.Write\\n\\n\\t-- We also freeze the dynamic datatype tables\\n\\treturn table.freeze({\\n\\t\\tEval = \\"Array\\",\\n\\t\\tOf = valueType.Eval, -- Example of adding extra data for the evaluator\\n\\t\\tRead = function(reader: Pack.ReaderData): { T }\\n\\t\\t\\tlocal len = Reader.u16(reader)\\n\\t\\t\\tlocal array = table.create(len) :: { T }\\n\\n\\t\\t\\tfor i = 1, len do\\n\\t\\t\\t\\tarray[i] = read(reader)\\n\\t\\t\\tend\\n\\n\\t\\t\\treturn array\\n\\t\\tend,\\n\\t\\tWrite = function(writer: Pack.WriterData, value: { T })\\n\\t\\t\\tlocal len = #value\\n\\t\\t\\tWriter.alloc(writer, 2)\\n\\t\\t\\tWriter.u16(writer, len)\\n\\n\\t\\t\\tfor i = 1, len do\\n\\t\\t\\t\\twrite(writer, value[i])\\n\\t\\t\\tend\\n\\t\\tend,\\n\\t}) :: Pack.DatatypeInterface<{ T }>\\n-- We also want to annotate a basic type for dynamic datatypes for type inference in Schemas\\nend :: <T>(T) -> { T }\\n```\\n\\nWhen making your own datatypes, you only have to worry about Eval if you want to use that datatype inside Union","source":{"line":155,"path":"src/types.luau"}}')}}]);