"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[552],{3897:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"Datatypes/Primitives","title":"Primitives","description":"In Pack, a primitive datatype refers to datatypes that contain only their own data. By this definition, Datatypes like Vector3 are treated as primitives, where they might normally be called compount datatypes or aggregate datatypes.","source":"@site/docs/Datatypes/Primitives.md","sourceDirName":"Datatypes","slug":"/Datatypes/Primitives","permalink":"/Pack/docs/Datatypes/Primitives","draft":false,"unlisted":false,"editUrl":"https://github.com/isoopod/Pack/edit/master/docs/Datatypes/Primitives.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"defaultSidebar","previous":{"title":"Installation","permalink":"/Pack/docs/Installation"},"next":{"title":"Structural Datatypes","permalink":"/Pack/docs/Datatypes/Structures"}}');var s=i(4848),a=i(8453);const r={sidebar_position:1},l="Primitive Datatypes",o={},d=[{value:"Any",id:"any",level:2},{value:"BitField",id:"bitfield",level:2},{value:"Boolean",id:"boolean",level:2},{value:"BrickColor",id:"brickcolor",level:2},{value:"BufferFixed",id:"bufferfixed",level:2},{value:"Buffer8",id:"buffer8",level:2},{value:"Buffer16",id:"buffer16",level:2},{value:"Buffer24",id:"buffer24",level:2},{value:"Buffer32",id:"buffer32",level:2},{value:"CFrame",id:"cframe",level:2},{value:"Color3",id:"color3",level:2},{value:"Color3float32",id:"color3float32",level:2},{value:"DateTime",id:"datetime",level:2},{value:"EnumItem",id:"enumitem",level:2},{value:"Float16",id:"float16",level:2},{value:"Float24",id:"float24",level:2},{value:"Float32",id:"float32",level:2},{value:"Float64",id:"float64",level:2},{value:"Instance",id:"instance",level:2},{value:"Int8",id:"int8",level:2},{value:"Int16",id:"int16",level:2},{value:"Int32",id:"int32",level:2},{value:"Int64",id:"int64",level:2},{value:"Null",id:"null",level:2},{value:"Object",id:"object",level:2},{value:"Region3",id:"region3",level:2},{value:"Region3int16",id:"region3int16",level:2},{value:"StringFixed",id:"stringfixed",level:2},{value:"String8",id:"string8",level:2},{value:"String16",id:"string16",level:2},{value:"String24",id:"string24",level:2},{value:"String32",id:"string32",level:2},{value:"UDim",id:"udim",level:2},{value:"UDim2",id:"udim2",level:2},{value:"UInt8",id:"uint8",level:2},{value:"UInt16",id:"uint16",level:2},{value:"UInt32",id:"uint32",level:2},{value:"UInt64",id:"uint64",level:2},{value:"Vector2float32",id:"vector2float32",level:2},{value:"Vector2float64",id:"vector2float64",level:2},{value:"Vector2float24",id:"vector2float24",level:2},{value:"Vector2float16",id:"vector2float16",level:2},{value:"Vector2int16",id:"vector2int16",level:2},{value:"Vector3float32",id:"vector3float32",level:2},{value:"Vector3float64",id:"vector3float64",level:2},{value:"Vector3float24",id:"vector3float24",level:2},{value:"Vector3float16",id:"vector3float16",level:2},{value:"Vector3int16",id:"vector3int16",level:2}];function c(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"primitive-datatypes",children:"Primitive Datatypes"})}),"\n",(0,s.jsx)(n.p,{children:"In Pack, a primitive datatype refers to datatypes that contain only their own data. By this definition, Datatypes like Vector3 are treated as primitives, where they might normally be called compount datatypes or aggregate datatypes."}),"\n",(0,s.jsx)(n.h2,{id:"any",children:"Any"}),"\n",(0,s.jsxs)(n.p,{children:["The Any datatype attempts to automatically encode any value inserted, at the cost of a much higher overhead. Currently, Any has few optimizations for tables, treating them all as arrays of any when possible (1 byte overhead for each value), otherwise falling back to a map of ",(0,s.jsx)(n.code,{children:"[any]: any"})," (2 bytes of overhead for each key-value pair) and does not support metatables or functions."]}),"\n",(0,s.jsx)(n.h2,{id:"bitfield",children:"BitField"}),"\n",(0,s.jsxs)(n.p,{children:["A BitField is a highly compressed array of booleans, using bit packing to fit eight booleans into one byte, instead of the usual one.",(0,s.jsx)(n.br,{}),"\n","To use this datatype, you must pass in a fixed length of how many booleans it is expected to store.",(0,s.jsx)(n.br,{}),"\n","When writing to this datatype, it is in the format of an array of booleans. If the array is shorter than the expected length, the last values will be treated as false.",(0,s.jsx)(n.br,{}),"\n","Reading it will return the array of booleans in the same order."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["You should try to have the defined length as close to a multiple of eight as possible.",(0,s.jsx)(n.br,{}),"\n","If your bitfield length is a mutliple of 8 (including 0) + 1, use a regular boolean for that last bool instead."]})}),"\n",(0,s.jsx)(n.h2,{id:"boolean",children:"Boolean"}),"\n",(0,s.jsx)(n.p,{children:"Encodes a true/false value into a single byte."}),"\n",(0,s.jsx)(n.h2,{id:"brickcolor",children:"BrickColor"}),"\n",(0,s.jsx)(n.p,{children:"Encodes a BrickColor value in 2 bytes."}),"\n",(0,s.jsx)(n.h2,{id:"bufferfixed",children:"BufferFixed"}),"\n",(0,s.jsxs)(n.p,{children:["BufferFixed refers a fixed length buffer, where a buffer of a known length will encoded with zero overhead.",(0,s.jsx)(n.br,{}),"\n","The fixed length of the buffer in bytes must be passed in."]}),"\n",(0,s.jsx)(n.h2,{id:"buffer8",children:"Buffer8"}),"\n",(0,s.jsx)(n.p,{children:"Encodes a buffer of variable length between 0 and 255 bytes with 1 byte of overhead."}),"\n",(0,s.jsx)(n.h2,{id:"buffer16",children:"Buffer16"}),"\n",(0,s.jsx)(n.p,{children:"Encodes a buffer of variable length between 0 and 65,535 bytes with 2 bytes of overhead."}),"\n",(0,s.jsx)(n.h2,{id:"buffer24",children:"Buffer24"}),"\n",(0,s.jsx)(n.p,{children:"Encodes a buffer of variable length between 0 and 16 MiB with 3 bytes of overhead."}),"\n",(0,s.jsx)(n.h2,{id:"buffer32",children:"Buffer32"}),"\n",(0,s.jsx)(n.p,{children:"Encodes a buffer of any length with 4 bytes of overhead. The maximum length with a buffer32 is greater than the 1 GiB size limit of buffers."}),"\n",(0,s.jsx)(n.h2,{id:"cframe",children:"CFrame"}),"\n",(0,s.jsx)(n.p,{children:"Encodes a CFrame as either 13 or 19 bytes. A standard Vector3 is used for position. Axis-Aligned CFrames are 13 bytes, otherwise for random orientation CFrames they are encoded in 19 bytes using a Quaternion for rotation, with an average precision of 0.00461\xb0 (more than enough)."}),"\n",(0,s.jsx)(n.h2,{id:"color3",children:"Color3"}),"\n",(0,s.jsx)(n.p,{children:"Encodes a Color3 value as standard 24-bit RGB in 3 bytes."}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["The Color3 Datatype actually uses 32 bit floats to store RGB, meaning sometimes colors will have RGB values above 255.",(0,s.jsx)(n.br,{}),"\n","If this is necessary, use Color3float32 instead"]})}),"\n",(0,s.jsx)(n.h2,{id:"color3float32",children:"Color3float32"}),"\n",(0,s.jsx)(n.p,{children:"Enodes a Color3 value in full using 12 bytes. This is for when you have colors with RGB values above 255."}),"\n",(0,s.jsx)(n.h2,{id:"datetime",children:"DateTime"}),"\n",(0,s.jsx)(n.p,{children:"Encodes a DateTime with millisecond precision using 8 bytes."}),"\n",(0,s.jsx)(n.h2,{id:"enumitem",children:"EnumItem"}),"\n",(0,s.jsxs)(n.p,{children:["Encodes an EnumItem from a provided Roblox Enum using between 1 and 2 bytes.",(0,s.jsx)(n.br,{}),"\n","Some common Enums such as Material and KeyCode use 2 bytes due to how these Enums were set up (they have items with values going past 255)"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"-- Pass in which Enum you are using\nPack:DefineSchema(Pack.EnumItem(Enum.KeyCode))\n"})}),"\n",(0,s.jsx)(n.h2,{id:"float16",children:"Float16"}),"\n",(0,s.jsx)(n.p,{children:"Encodes a 16-bit floating point number using 2 bytes"}),"\n",(0,s.jsx)(n.p,{children:"Range:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Subnormal: \xb16.1\xd710",(0,s.jsx)("sup",{children:"-5"})]}),"\n",(0,s.jsxs)(n.li,{children:["Normal: \xb16.5\xd710",(0,s.jsx)("sup",{children:"4"}),"\nPrecision: ~3.3 decimal places"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"float24",children:"Float24"}),"\n",(0,s.jsx)(n.p,{children:"Encodes a 24-bit floating point number using 3 bytes"}),"\n",(0,s.jsx)(n.p,{children:"Range:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Subnormal: \xb11\xd710",(0,s.jsx)("sup",{children:"-19"})]}),"\n",(0,s.jsxs)(n.li,{children:["Normal: \xb12\xd710",(0,s.jsx)("sup",{children:"19"}),"\nPrecision: ~5.9 decimal places"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"float32",children:"Float32"}),"\n",(0,s.jsx)(n.admonition,{title:"Aliases",type:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Float"})," is an alias for Float32 and can be used instead"]})}),"\n",(0,s.jsx)(n.p,{children:"Encodes a 32-bit floating point number using 4 bytes"}),"\n",(0,s.jsx)(n.p,{children:"Range:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Subnormal: \xb11.2\xd710",(0,s.jsx)("sup",{children:"-38"})]}),"\n",(0,s.jsxs)(n.li,{children:["Normal: \xb13.4\xd710",(0,s.jsx)("sup",{children:"38"}),"\nPrecision: ~7.2 decimal places"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"float64",children:"Float64"}),"\n",(0,s.jsx)(n.admonition,{title:"Aliases",type:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Double"})," is an alias for Float64 and can be used instead"]})}),"\n",(0,s.jsx)(n.p,{children:"Enocdes a 64-bit floating point number using 8 bytes. This is the type used by lua numbers. It is also the only numeric type that can be used for UserIds, as those have passed the 32-bit unsigned integer limit."}),"\n",(0,s.jsx)(n.p,{children:"Range:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Subnormal: \xb12.2\xd710",(0,s.jsx)("sup",{children:"-308"})]}),"\n",(0,s.jsxs)(n.li,{children:["Normal: \xb11.8\xd710",(0,s.jsx)("sup",{children:"308"}),"\nPrecision: ~15.9 decimal places"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"instance",children:"Instance"}),"\n",(0,s.jsxs)(n.p,{children:["Encodes a reference to an Instance. This will place a UID tag on the instance so it can be located later. This UID is 4 bytes.",(0,s.jsx)(n.br,{}),"\n","Note that the UID tag is not removed, as"]}),"\n",(0,s.jsxs)(n.admonition,{type:"warning",children:[(0,s.jsx)(n.p,{children:"This reference does not persist between server and client"}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"WRITE UNSAFE"}),(0,s.jsx)(n.br,{}),"\n","Writing a reference to an Instance that does not already have a UID will synchronize the thread"]})]}),"\n",(0,s.jsx)(n.p,{children:"In saving places, references persist between server runtimes."}),"\n",(0,s.jsx)(n.h2,{id:"int8",children:"Int8"}),"\n",(0,s.jsx)(n.admonition,{title:"Aliases",type:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Byte"})," is an alias for Int8 and can be used instead"]})}),"\n",(0,s.jsxs)(n.p,{children:["Enocdes an 8-bit signed integer in a single byte.",(0,s.jsx)(n.br,{}),"\n","Range: -128 \u2013 +127"]}),"\n",(0,s.jsx)(n.h2,{id:"int16",children:"Int16"}),"\n",(0,s.jsx)(n.admonition,{title:"Aliases",type:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Short"})," is an alias for Int16 and can be used instead"]})}),"\n",(0,s.jsxs)(n.p,{children:["Encodes a 16-bit signed integer in 2 bytes.",(0,s.jsx)(n.br,{}),"\n","Range: -32,768 \u2013 +32,767"]}),"\n",(0,s.jsx)(n.h2,{id:"int32",children:"Int32"}),"\n",(0,s.jsx)(n.admonition,{title:"Aliases",type:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Int"})," is an alias for Int32 and can be used instead"]})}),"\n",(0,s.jsx)(n.p,{children:"Encodes a 32-bit signed integer in 4 bytes.\nRange: -2,147,483,648 \u2013 +2,147,483,647"}),"\n",(0,s.jsx)(n.h2,{id:"int64",children:"Int64"}),"\n",(0,s.jsx)(n.admonition,{title:"Aliases",type:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Long"})," is an alias for Int64 and can be used instead"]})}),"\n",(0,s.jsx)(n.p,{children:"Encodes a 64-bit signed integer using 8 bytes."}),"\n",(0,s.jsxs)(n.p,{children:["This datatype is implemented using two 32-bit segments due to Luau's ",(0,s.jsx)(n.code,{children:"number"})," type limitations, which only supports exact representation up to 2",(0,s.jsx)("sup",{children:"53"})," \u2212 1.\nThe value is split into a low and high 32-bit integer in little-endian order (low first, then high), and recombined on read."]}),"\n",(0,s.jsx)(n.p,{children:"Range (exact): \u22129,007,199,254,740,991 \u2013 +9,007,199,254,740,991"}),"\n",(0,s.jsxs)(n.p,{children:["Values beyond this safe range lose precision due to the limitations of Luau\u2019s number type (IEEE 754 double).\nUse only for integers within \xb12",(0,s.jsx)("sup",{children:"53"})," for guaranteed correctness.",(0,s.jsx)(n.br,{}),"\n","See ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Double-precision_floating-point_format#Precision_limitations_on_integer_values",children:"Wikipedia"})," for how Doubles lose integer precision."]}),"\n",(0,s.jsx)(n.p,{children:"Int64 values used in the Roblox ecosystem, such as AssetIds and UserIds take Luau's number limitations into account, so Int64 and UInt64 can be used to store these."}),"\n",(0,s.jsx)(n.h2,{id:"null",children:"Null"}),"\n",(0,s.jsx)(n.p,{children:"Represents nothing, directly uses zero bytes. For use in the Union structure (WIP)"}),"\n",(0,s.jsx)(n.h2,{id:"object",children:"Object"}),"\n",(0,s.jsxs)(n.p,{children:["Allows marshalling a lua object by providing the class's metatable, and a ",(0,s.jsx)(n.a,{href:"Structures/#dictionary",children:"Dictionary"})," of members to serialize from the object.",(0,s.jsx)(n.br,{}),"\n","This should work for most common OOP patterns. An example has been provided for the classic lua OOP paradigm."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"-- Example Class --\nlocal exampleClass = {}\nexampleClass.__index = exampleClass\n\nfunction exampleClass:SomeMethod(val: number)\n    self.someProperty = val\nend\n\nfunction exampleClass.new(val: number)\n    local self = setmetatable({}, exampleClass)\n\n    self.someProperty = val\n\n    return self\nend\n----\n\n-- Create a schema to marshall exampleClass by providing its metatable \n-- as well as instructions to serialize its properties\nlocal schema = Pack:DefineSchema(Pack.object(getmetatable(exampleClass), Pack.Dictionary({\n    someProperty = Pack.Double\n})))\n----\n\n-- Test it with an object of exampleClass\nlocal exampleObject = exampleClass.new(1)\n\nprint(exampleObject.someProperty) -- >>> 1\nexampleObject:SomeMethod(10)\nprint(exampleObject.someProperty) -- >>> 10\n\nlocal reconstructedObject = schema:Read(schema:Write(exampleObject))\n\nprint(reconstructedObject.someProperty) -- >>> 10\nreconstructedObject:SomeMethod(100)\nprint(reconstructedObject.someProperty) -- >>> 100\n"})}),"\n",(0,s.jsx)(n.h2,{id:"region3",children:"Region3"}),"\n",(0,s.jsx)(n.p,{children:"Encodes a Region3 as a min and max Vector3, giving a total of 24 bytes."}),"\n",(0,s.jsx)(n.h2,{id:"region3int16",children:"Region3int16"}),"\n",(0,s.jsx)(n.p,{children:"Encodes a Region3int16 as a min and max Vector3int16, giving a total of 12 bytes."}),"\n",(0,s.jsx)(n.h2,{id:"stringfixed",children:"StringFixed"}),"\n",(0,s.jsxs)(n.p,{children:["StringFixed refers a fixed length string, where a string of a known length will encoded with zero overhead.",(0,s.jsx)(n.br,{}),"\n","The fixed length of the string in bytes must be passed in."]}),"\n",(0,s.jsx)(n.h2,{id:"string8",children:"String8"}),"\n",(0,s.jsxs)(n.p,{children:["Encodes a string of variable length between 0 and 255 bytes with 1 byte of overhead.",(0,s.jsx)(n.br,{}),"\n","Chars already have a variable length of 1-4, so this can range from 255 chars to 63 chars."]}),"\n",(0,s.jsx)(n.h2,{id:"string16",children:"String16"}),"\n",(0,s.jsx)(n.p,{children:"Encodes a string of variable length between 0 and 65,535 bytes with 2 bytes of overhead.\nChars already have a variable length of 1-4, so this can range from 65,535 chars to 16,383 chars."}),"\n",(0,s.jsx)(n.h2,{id:"string24",children:"String24"}),"\n",(0,s.jsx)(n.p,{children:"Encodes a string of variable length between 0 and 16 MiB with 3 bytes of overhead."}),"\n",(0,s.jsx)(n.h2,{id:"string32",children:"String32"}),"\n",(0,s.jsx)(n.p,{children:"Encodes a string of any length with 4 bytes of overhead. The maximum length with a string32 is bigger than the 1 GiB size limit of buffers."}),"\n",(0,s.jsx)(n.h2,{id:"udim",children:"UDim"}),"\n",(0,s.jsxs)(n.p,{children:["Encodes a single UDim as 6 bytes.",(0,s.jsx)(n.br,{}),"\n","We assume the offset will be within the range of a int16. If this is not the case, you will have to send the UDim as a float32 scale and int32 offset."]}),"\n",(0,s.jsx)(n.h2,{id:"udim2",children:"UDim2"}),"\n",(0,s.jsx)(n.p,{children:"Encodes a UDim2 as 12 bytes.\nWe assume the offset will be within the range of a int16. If this is not the case, you will have to send the two UDims as a float32 scale and int32 offset."}),"\n",(0,s.jsx)(n.h2,{id:"uint8",children:"UInt8"}),"\n",(0,s.jsx)(n.admonition,{title:"Aliases",type:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"UByte"})," is an alias for UInt8 and can be used instead"]})}),"\n",(0,s.jsxs)(n.p,{children:["Enocdes an 8-bit unsigned integer in a single byte.",(0,s.jsx)(n.br,{}),"\n","Range: [0\u2013255]"]}),"\n",(0,s.jsx)(n.h2,{id:"uint16",children:"UInt16"}),"\n",(0,s.jsx)(n.admonition,{title:"Aliases",type:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"UShort"})," is an alias for UInt16 and can be used instead"]})}),"\n",(0,s.jsxs)(n.p,{children:["Encodes a 16-bit unsigned integer in 2 bytes.",(0,s.jsx)(n.br,{}),"\n","Range: [0\u201365,565]"]}),"\n",(0,s.jsx)(n.h2,{id:"uint32",children:"UInt32"}),"\n",(0,s.jsx)(n.admonition,{title:"Aliases",type:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"UInt"})," is an alias for UInt32 and can be used instead"]})}),"\n",(0,s.jsx)(n.p,{children:"Encodes a 32-bit unsigned integer in 4 bytes.\nRange: [0\u20134,294,967,295]"}),"\n",(0,s.jsx)(n.h2,{id:"uint64",children:"UInt64"}),"\n",(0,s.jsx)(n.admonition,{title:"Aliases",type:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"ULong"})," is an alias for UInt56 and can be used instead"]})}),"\n",(0,s.jsx)(n.p,{children:"Encodes a 64-bit unsigned integer using 8 bytes."}),"\n",(0,s.jsxs)(n.p,{children:["Like ",(0,s.jsx)(n.a,{href:"#int64",children:"Int64"}),", this is encoded by splitting the number into low and high 32-bit unsigned segments in little-endian order (low first, then high), and combining them when reading.\nRange (exact): [0\u20139,007,199,254,740,992]"]}),"\n",(0,s.jsxs)(n.p,{children:["Although UInt64 can store exact integers up to 2",(0,s.jsx)("sup",{children:"53"}),", Luau numbers lose precision above 2",(0,s.jsx)("sup",{children:"53"}),".",(0,s.jsx)(n.br,{}),"\n","Refer to ",(0,s.jsx)(n.a,{href:"#int64",children:"Int64"})," for more info."]}),"\n",(0,s.jsx)(n.h2,{id:"vector2float32",children:"Vector2float32"}),"\n",(0,s.jsx)(n.admonition,{title:"Aliases",type:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Vector2"})," is an alias for Vector2float32 and can be used instead"]})}),"\n",(0,s.jsx)(n.p,{children:"Encodes a 2D vector of float32s using 8 bytes."}),"\n",(0,s.jsxs)(n.p,{children:["see ",(0,s.jsx)(n.a,{href:"#float32",children:"Float32"})," for approximate range and precision of each component."]}),"\n",(0,s.jsx)(n.h2,{id:"vector2float64",children:"Vector2float64"}),"\n",(0,s.jsx)(n.p,{children:"Encodes a 2D vector of float64s using 16 bytes."}),"\n",(0,s.jsxs)(n.p,{children:["see ",(0,s.jsx)(n.a,{href:"#float64",children:"Float64"})," for approximate range and precision of each component."]}),"\n",(0,s.jsx)(n.h2,{id:"vector2float24",children:"Vector2float24"}),"\n",(0,s.jsx)(n.p,{children:"Encodes a 2D vector of float24s using 6 bytes."}),"\n",(0,s.jsxs)(n.p,{children:["see ",(0,s.jsx)(n.a,{href:"#float24",children:"Float24"})," for approximate range and precision of each component."]}),"\n",(0,s.jsx)(n.h2,{id:"vector2float16",children:"Vector2float16"}),"\n",(0,s.jsx)(n.p,{children:"Encodes a 2D vector of float16s with 4 bytes."}),"\n",(0,s.jsxs)(n.p,{children:["see ",(0,s.jsx)(n.a,{href:"#float16",children:"Float16"})," for approximate range and precision of each component."]}),"\n",(0,s.jsx)(n.h2,{id:"vector2int16",children:"Vector2int16"}),"\n",(0,s.jsx)(n.p,{children:"Encodes a 2D vector of int16s using 4 bytes."}),"\n",(0,s.jsx)(n.h2,{id:"vector3float32",children:"Vector3float32"}),"\n",(0,s.jsx)(n.admonition,{title:"Aliases",type:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Vector3"})," is an alias for Vector3float32 and can be used instead"]})}),"\n",(0,s.jsx)(n.p,{children:"Encodes a 3D vector of float32s using 12 bytes."}),"\n",(0,s.jsxs)(n.p,{children:["see ",(0,s.jsx)(n.a,{href:"#float32",children:"Float32"})," for approximate range and precision of each component."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Compatible with the Roblox Vector3 library and luau vector library.",(0,s.jsx)(n.br,{}),"\n","Will return as a luau vector, but these are interchangeable with the Vector3 library.",(0,s.jsx)(n.br,{}),"\n","(Vector3 methods can be used on vectors and vector library functions can take Vector3s)"]})}),"\n",(0,s.jsx)(n.h2,{id:"vector3float64",children:"Vector3float64"}),"\n",(0,s.jsx)(n.p,{children:"Encodes a 3D vector of float64s using 24 bytes."}),"\n",(0,s.jsxs)(n.p,{children:["see ",(0,s.jsx)(n.a,{href:"#float64",children:"Float64"})," for approximate range and precision of each component."]}),"\n",(0,s.jsx)(n.h2,{id:"vector3float24",children:"Vector3float24"}),"\n",(0,s.jsx)(n.p,{children:"Encodes a 3D vector of float24s using 9 bytes."}),"\n",(0,s.jsxs)(n.p,{children:["see ",(0,s.jsx)(n.a,{href:"#float24",children:"Float24"})," for approximate range and precision of each component."]}),"\n",(0,s.jsx)(n.h2,{id:"vector3float16",children:"Vector3float16"}),"\n",(0,s.jsx)(n.p,{children:"Encodes a 3D vector of float16s with 6 bytes."}),"\n",(0,s.jsxs)(n.p,{children:["see ",(0,s.jsx)(n.a,{href:"#float16",children:"Float16"})," for approximate range and precision of each component."]}),"\n",(0,s.jsx)(n.h2,{id:"vector3int16",children:"Vector3int16"}),"\n",(0,s.jsx)(n.p,{children:"Encodes a 3D vector of int16s with 6 bytes."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var t=i(6540);const s={},a=t.createContext(s);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);