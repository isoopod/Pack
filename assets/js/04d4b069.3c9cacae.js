"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[286],{88783:e=>{e.exports=JSON.parse('{"functions":[{"name":"alloc","desc":"Most Writer functions will not automatically allocate length to the buffer, instead opting to make this call as few times as possible when writing a datatype.  \\nFunctions that do allocate will be marked with the Allocating tag. Otherwise, figure out how many bytes you need to allocate and call Writer.alloc","params":[{"name":"self","desc":"A writer instance created with .new","lua_type":"WriterData"},{"name":"bytes","desc":"The number of bytes to allocate","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":26,"path":"src/Writer.luau"}},{"name":"u8","desc":"**1 byte**  \\nWrites an 8-bit unsigned integer into the packet ","params":[{"name":"self","desc":"A writer instance created with .new","lua_type":"WriterData"},{"name":"value","desc":"","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":57,"path":"src/Writer.luau"}},{"name":"u16","desc":"**2 bytes**  \\nWrites a 16-bit unsigned integer into the packet ","params":[{"name":"self","desc":"A writer instance created with .new","lua_type":"WriterData"},{"name":"value","desc":"","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":70,"path":"src/Writer.luau"}},{"name":"u32","desc":"**4 bytes**  \\nWrites a 32-bit unsigned integer into the packet ","params":[{"name":"self","desc":"A writer instance created with .new","lua_type":"WriterData"},{"name":"value","desc":"","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":83,"path":"src/Writer.luau"}},{"name":"i8","desc":"**1 bytes**  \\nWrites an 8-bit signed integer into the packet ","params":[{"name":"self","desc":"A writer instance created with .new","lua_type":"WriterData"},{"name":"value","desc":"","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":96,"path":"src/Writer.luau"}},{"name":"i16","desc":"**2 bytes**  \\nWrites a 16-bit signed integer into the packet ","params":[{"name":"self","desc":"A writer instance created with .new","lua_type":"WriterData"},{"name":"value","desc":"","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":109,"path":"src/Writer.luau"}},{"name":"i32","desc":"**4 bytes**  \\nWrites a 32-bit signed integer into the packet ","params":[{"name":"self","desc":"A writer instance created with .new","lua_type":"WriterData"},{"name":"value","desc":"","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":122,"path":"src/Writer.luau"}},{"name":"nBitUint","desc":"**`math.floor(n / 8) + 1` bytes**  \\nWrites an unsigned `n`-bit integer into the packet \\n:::info\\nnBitUint does not automatically move the writers cursor so you will have to call \\nWriter.moveCursor the appropriate number of bytes after writing a section of nBit numbers.\\n:::","params":[{"name":"self","desc":"A writer instance created with .new","lua_type":"WriterData"},{"name":"value","desc":"","lua_type":"number"},{"name":"n","desc":"The length of the integer in bits","lua_type":"number"},{"name":"bitOffset","desc":"The offset from the cursor in bits to start writing at [0 \u2013 31]","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":141,"path":"src/Writer.luau"}},{"name":"nBitInt","desc":"**`math.floor(n / 8) + 1` bytes**  \\nWrites a signed `n`-bit integer into the packet \\n:::info\\nnBitInt does not automatically move the writers cursor so you will have to call \\nWriter.moveCursor the appropriate number of bytes after writing a section of nBit numbers.\\n:::","params":[{"name":"self","desc":"A writer instance created with .new","lua_type":"WriterData"},{"name":"value","desc":"","lua_type":"number"},{"name":"n","desc":"The length of the integer in bits","lua_type":"number"},{"name":"bitOffset","desc":"The offset from the cursor in bits to start writing at [0 \u2013 31]","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":159,"path":"src/Writer.luau"}},{"name":"nBitFloat","desc":"**`math.floor((1 + n + m) / 8) + 1` bytes**  \\nWrites a floating point number into the packet \\n:::info\\nnBitFloat does not automatically move the writer\'s cursor so you will have to call \\nWriter.moveCursor the appropriate number of bytes after writing a section of nBit numbers.\\n:::\\n:::warning\\nThe sum of `n` and `m` should not be greater than `31 - bitOffset`.  \\n:::","params":[{"name":"self","desc":"A writer instance created with .new","lua_type":"WriterData"},{"name":"value","desc":"","lua_type":"number"},{"name":"n","desc":"The length in bits of the floating point\'s exponent","lua_type":"number"},{"name":"m","desc":"The length in bits of the floating point\'s mantissa","lua_type":"number"},{"name":"bitOffset","desc":"The offset from the cursor in bits to start writing at [0 \u2013 31]","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":181,"path":"src/Writer.luau"}},{"name":"f32","desc":"**4 bytes**  \\nWrites a 32-bit floating point number into the packet ","params":[{"name":"self","desc":"A writer instance created with .new","lua_type":"WriterData"},{"name":"value","desc":"","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":256,"path":"src/Writer.luau"}},{"name":"f64","desc":"**8 bytes**  \\nWrites a 64-bit floating point number into the packet ","params":[{"name":"self","desc":"A writer instance created with .new","lua_type":"WriterData"},{"name":"value","desc":"","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":269,"path":"src/Writer.luau"}},{"name":"string","desc":"Write a string into the buffer. The count/length can be obtained using the len `#` operator on the string, which returns the length of the string in bytes.","params":[{"name":"self","desc":"A writer instance created with .new","lua_type":"WriterData"},{"name":"value","desc":"The string you wish to write","lua_type":"string"},{"name":"count","desc":"Length of the string to write in bytes","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":282,"path":"src/Writer.luau"}},{"name":"moveCursor","desc":"Manually moves the writer\'s cursor.  \\n:::danger\\nDoes not prevent you from leaving buffer bounds.\\n:::","params":[{"name":"self","desc":"A writer instance created with .new","lua_type":"WriterData"},{"name":"delta","desc":"How many bytes to move the cursor, can be negative to go backwards","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":297,"path":"src/Writer.luau"}},{"name":"Finalize","desc":"Finalizes the packet by writing the bit buffer and trimming the main buffer to the correct size.","params":[{"name":"self","desc":"A writer instance created with .new","lua_type":"WriterData"}],"returns":[{"desc":"","lua_type":"buffer"}],"function_type":"static","source":{"line":324,"path":"src/Writer.luau"}},{"name":"new","desc":"Creates an empty writer instance","params":[{"name":"approxLen","desc":"Optional approximate length of the buffer to be created. This is used to preallocate the buffer size so less resizes are needed.","lua_type":"number?"},{"name":"approxBitLen","desc":"Optional approximate length of the bit buffer to be created. This is used to preallocate the bit buffer size so less resizes are needed.","lua_type":"number?"}],"returns":[{"desc":"","lua_type":"WriterData"}],"function_type":"static","tags":["Constructor"],"source":{"line":346,"path":"src/Writer.luau"}}],"properties":[],"types":[],"name":"Writer","desc":"The internal Writer class. A dynamically expanding buffer with predictive initial sizing depending on the schema.\\nA writer instance is created with the .new constructor, and is modified with the library\'s functions.","source":{"line":15,"path":"src/Writer.luau"}}')}}]);