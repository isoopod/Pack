{"searchDocs":[{"title":"Pack","type":0,"sectionRef":"#","url":"/Pack/api/Pack","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Pack","url":"/Pack/api/Pack#functions","content":" ","version":null,"tagName":"h2"},{"title":"Define​","type":1,"pageTitle":"Pack","url":"/Pack/api/Pack#Define","content":"&lt;/&gt; Pack:Define( ...: Datatype-- See all datatypes in Docs/Datatypes ) → Schema Defines a Schema from the provided datatypes. This supports tuples, however due to luau limitations you will need to manually annotate the type. local Pack = require(path.to.pack) -- The type of this schema will implicitly be infered as CFrame local exampleSchema = Pack:Define(Pack.CFrame) -- For tuples, you must explicitly annotate the type of the schema using Pack.Schema&lt;...&gt;. -- The luau type solver can only infer the first argument. local tupleSchema = Pack:Define(Pack.CFrame, Pack.Vector3) :: Pack.Schema&lt;CFrame, Vector3&gt;  ","version":null,"tagName":"h3"},{"title":"Schema","type":0,"sectionRef":"#","url":"/Pack/api/Schema","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Schema","url":"/Pack/api/Schema#functions","content":" ","version":null,"tagName":"h2"},{"title":"Write​","type":1,"pageTitle":"Schema","url":"/Pack/api/Schema#Write","content":"&lt;/&gt; Schema:Write(...: any) → ( buffer,-- This is your 'packet' that can be sent around or stored and later read by this schema. {any}-- Table of refs for datatypes making use of this. Stock Pack does not use this and this is intended for Networking. ) Writes a packet (buffer) from the provided input, which should follow the structure of the schema.  ","version":null,"tagName":"h3"},{"title":"Read​","type":1,"pageTitle":"Schema","url":"/Pack/api/Schema#Read","content":"&lt;/&gt; Schema:Read( packet: buffer,-- A packet created by this schema with the Write method. refs: {any}?-- Optional table of refs for datatypes making use of this. Stock Pack does not use this and this is intended for Networking. ) → (...any)-- This is a reconstruction of the input to the packet. Reads a packet (buffer) that was written with the same schema and outputs a reconstruction of the packet's input. ","version":null,"tagName":"h3"},{"title":"Datatype","type":0,"sectionRef":"#","url":"/Pack/api/Datatype","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Datatype","url":"/Pack/api/Datatype#types","content":" ","version":null,"tagName":"h2"},{"title":"DatatypeInterface<T>​","type":1,"pageTitle":"Datatype","url":"/Pack/api/Datatype#DatatypeInterface<T>","content":"&lt;/&gt; type DatatypeInterface&lt;T&gt; = { Eval: string?, Read: (ReaderData) → T, Write: ( writer: WriterData, value: T ) → () } Eval is a string indicating which evaluator to use for this value if applicable. Extra info can be added regarding this for advanced datatypes. Read is a function that is passed a ReaderData instance and expected to read the ReaderData and return whatever was passed into Write. Write is a function that is passed a WriterData instance and a value and is expected to write the value into WriterData. ","version":null,"tagName":"h3"},{"title":"Miscellaneous Datatypes","type":0,"sectionRef":"#","url":"/Pack/docs/Datatypes/Miscellaneous","content":"","keywords":"","version":"Next"},{"title":"Custom​","type":1,"pageTitle":"Miscellaneous Datatypes","url":"/Pack/docs/Datatypes/Miscellaneous#custom","content":" The Custom datatype is used as a simple way to create a custom datatype that will be used once. If performance is essential or the datatype needs to be reused, you can create an extension datatype using the exposed internal Pack types.  -- See the API reference for the Reader and Writer libraries. -- In this example, the datatype just represents a float64 Pack:DefineSchema( Pack.Custom( function(reader) return Pack.Reader.f64(reader) end, function(writer, val: number) Pack.Writer.alloc(writer, 4) Pack.Writer.f64(writer, val) end ) )   ","version":"Next","tagName":"h2"},{"title":"Transformer​","type":1,"pageTitle":"Miscellaneous Datatypes","url":"/Pack/docs/Datatypes/Miscellaneous#transformer","content":" The Transformer datatype functions as a convenient wrapper for transforming raw data into a more efficient format for encoding, and reversing that process. The format (usually a Dictionary) is how the data will be encoded by Pack. The encode function should take some data not that would not directly be accepted by format and transform it such that it can be. The decode function would then bring data encoded in that format and turn it back into the original format  encode and decode are both optional, allowing you to use the transformer for data normalization, such as filling in defaults.  type standard = { color: string -- Hex string enabled: &quot;True&quot; | &quot;False&quot; } Pack:DefineSchema( Pack.Transformer( Pack.Dicitonary({ color = Pack.Color3, enabled = Pack.Boolean, }), function(input: standard) local result = {} result.color = Color3.FromHex(input.color) result.enabled = input.enabled == &quot;True&quot; return result end, function(input) -- The type should be inferred as the same type as the dictionary local result = {} result.color = input.color:ToHex() result.enabled = input.enabled and &quot;True&quot; or &quot;False return result end ) )  ","version":"Next","tagName":"h2"},{"title":"Structural Datatypes","type":0,"sectionRef":"#","url":"/Pack/docs/Datatypes/Structures","content":"","keywords":"","version":"Next"},{"title":"Array​","type":1,"pageTitle":"Structural Datatypes","url":"/Pack/docs/Datatypes/Structures#array","content":" An array is an ordered collection of values with the same type. Arrays are one-based for consistency with lua. Arrays have two bytes of overhead and can contain a maximum of 65,565 elements.  Pack:DefineSchema(Pack.Array(Pack.Vector3))   ","version":"Next","tagName":"h2"},{"title":"Dictionary​","type":1,"pageTitle":"Structural Datatypes","url":"/Pack/docs/Datatypes/Structures#dictionary","content":" A Pack Dictionary refers to a table with predefined keys. This is sometimes called a struct in similar libraries. Dictionaries add no overhead.  Pack:DefineSchema(Pack.Dictionary({ -- Doesn't matter which way you assign string keys [&quot;A&quot;] = Pack.Float64, B = Pack.Float32, -- You aren't limited to just strings as the key. -- Beware that using non-string keys may break the typing, and explicit type annotation may not be able to fix it. [0] = Pack.CFrame, -- You can nest Dictionaries and use other structural datatypes inside a dictionary Nested = Pack.Dictionary({ A = Pack.String16, }), }))   ","version":"Next","tagName":"h2"},{"title":"Map​","type":1,"pageTitle":"Structural Datatypes","url":"/Pack/docs/Datatypes/Structures#map","content":" A Map is a mapping of some type of key to some type of value. This is very useful when used with the Union or any datatypes (WIP). Maps have two bytes of overhead to store the number of elements they contain.  -- Represents a table with string keys and Vector3 values Pack:DefineSchema(Pack.Map(Pack.string8, Pack.Vector3))   ","version":"Next","tagName":"h2"},{"title":"Nullable​","type":1,"pageTitle":"Structural Datatypes","url":"/Pack/docs/Datatypes/Structures#nullable","content":" The Nullable datatype indicates the value is optional and may be nil. This adds 1 byte of overhead for every nullable value.  -- A packet from this schema could be 1 bytes long or 13 bytes long, depending if the Vector3 was passed in or not. Pack:DefineSchema(Pack.Nullable(Pack.Vector3))   ","version":"Next","tagName":"h2"},{"title":"SparseDictionary​","type":1,"pageTitle":"Structural Datatypes","url":"/Pack/docs/Datatypes/Structures#sparsedictionary","content":" A Pack SparseDictionary refers to a table with predefined keys, each of which are optional. The second argument is for requried keys, which functions like a regular Dictionary. SparseDictionaries have the overhead of a BitField for all optional keys.  Pack:DefineSchema(Pack.SparseDictionary({ -- Optional keys CFrame = Pack.CFrame, Velocity = Pack.Vector3, -- Do not do: opt = Pack.Nullable(Pack.CFrame) -- All keys in the optional table are already nullable }))   ","version":"Next","tagName":"h2"},{"title":"Union​","type":1,"pageTitle":"Structural Datatypes","url":"/Pack/docs/Datatypes/Structures#union","content":" The Union datatype indicates a value may be one of many datatypes, adding 1 byte of overhead. The order of the values is the order they will be evaluated. ","version":"Next","tagName":"h2"},{"title":"Writer","type":0,"sectionRef":"#","url":"/Pack/api/Writer","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#functions","content":" ","version":null,"tagName":"h2"},{"title":"alloc​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#alloc","content":"&lt;/&gt; Writer.alloc( self: WriterData,-- A writer instance created with .new bytes: number-- The number of bytes to allocate ) → () Most Writer functions will not automatically allocate length to the buffer, instead opting to make this call as few times as possible when writing a datatype. Functions that do allocate will be marked with the Allocating tag. Otherwise, figure out how many bytes you need to allocate and call Writer.alloc  ","version":null,"tagName":"h3"},{"title":"u8​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#u8","content":"&lt;/&gt; Writer.u8( self: WriterData,-- A writer instance created with .new value: number ) → () 1 byte Orders an 8-bit unsigned integer to be written into the packet  ","version":null,"tagName":"h3"},{"title":"u16​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#u16","content":"&lt;/&gt; Writer.u16( self: WriterData,-- A writer instance created with .new value: number ) → () 2 bytes Orders a 16-bit unsigned integer to be written into the packet  ","version":null,"tagName":"h3"},{"title":"u32​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#u32","content":"&lt;/&gt; Writer.u32( self: WriterData,-- A writer instance created with .new value: number ) → () 4 bytes Orders a 32-bit unsigned integer to be written into the packet  ","version":null,"tagName":"h3"},{"title":"i8​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#i8","content":"&lt;/&gt; Writer.i8( self: WriterData,-- A writer instance created with .new value: number ) → () 1 bytes Orders an 8-bit signed integer to be written into the packet  ","version":null,"tagName":"h3"},{"title":"i16​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#i16","content":"&lt;/&gt; Writer.i16( self: WriterData,-- A writer instance created with .new value: number ) → () 2 bytes Orders a 16-bit signed integer to be written into the packet  ","version":null,"tagName":"h3"},{"title":"i32​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#i32","content":"&lt;/&gt; Writer.i32( self: WriterData,-- A writer instance created with .new value: number ) → () 4 bytes Orders a 32-bit signed integer to be written into the packet  ","version":null,"tagName":"h3"},{"title":"nBitUint​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#nBitUint","content":"&lt;/&gt; Writer.nBitUint( self: WriterData,-- A writer instance created with .new value: number, n: number,-- The length of the integer in bits bitOffset: number-- The offset from the cursor in bits to start writing at [0 – 31] ) → () math.floor(n / 8) + 1 bytes Orders an unsigned n-bit integer to be written into the packet INFO nBitUint does not automatically move the writers cursor so you will have to call Writer.moveCursor the appropriate number of bytes after writing a section of nBit numbers.  ","version":null,"tagName":"h3"},{"title":"nBitInt​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#nBitInt","content":"&lt;/&gt; Writer.nBitInt( self: WriterData,-- A writer instance created with .new value: number, n: number,-- The length of the integer in bits bitOffset: number-- The offset from the cursor in bits to start writing at [0 – 31] ) → () math.floor(n / 8) + 1 bytes Orders a signed n-bit integer to be written into the packet INFO nBitInt does not automatically move the writers cursor so you will have to call Writer.moveCursor the appropriate number of bytes after writing a section of nBit numbers.  ","version":null,"tagName":"h3"},{"title":"nBitFloat​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#nBitFloat","content":"&lt;/&gt; Writer.nBitFloat( self: WriterData,-- A writer instance created with .new value: number, n: number,-- The length in bits of the floating point's exponent m: number,-- The length in bits of the floating point's mantissa bitOffset: number-- The offset from the cursor in bits to start writing at [0 – 31] ) → () math.floor((1 + n + m) / 8) + 1 bytes Orders a signed n-bit integer to be written into the packet INFO nBitFloat does not automatically move the writers cursor so you will have to call Writer.moveCursor the appropriate number of bytes after writing a section of nBit numbers. WARNING The sum of n and m should not be greater than 31 - bitOffset.  ","version":null,"tagName":"h3"},{"title":"f32​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#f32","content":"&lt;/&gt; Writer.f32( self: WriterData,-- A writer instance created with .new value: number ) → () 4 bytes Orders a 32-bit floating point number to be written into the packet  ","version":null,"tagName":"h3"},{"title":"f64​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#f64","content":"&lt;/&gt; Writer.f64( self: WriterData,-- A writer instance created with .new value: number ) → () 8 bytes Orders a 64-bit floating point number to be written into the packet  ","version":null,"tagName":"h3"},{"title":"string​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#string","content":"Allocating &lt;/&gt; Writer.string( self: WriterData,-- A writer instance created with .new value: string,-- The string you wish to write count: number?-- Optional value denoting the maximum number of bytes to write ) → ( number,-- the length of the string in bytes () → ()-- A function that orders the wring to be written into the packet ) Processes a string into a seperate buffer and allocates the byte length of the string (or if count is provided and smaller than blen, allocates count bytes) Returns the amount of bytes allocated, and a function to insert the string write operation into the queue. This is so the length of the string can be written before writing the string itself, for variable length strings.  ","version":null,"tagName":"h3"},{"title":"moveCursor​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#moveCursor","content":"&lt;/&gt; Writer.moveCursor( self: WriterData,-- A writer instance created with .new delta: number-- How many bytes to move the cursor, can be negative to go backwards ) → () Manually moves the writer's cursor. DANGER Does not prevent you from leaving buffer bounds.  ","version":null,"tagName":"h3"},{"title":"Finalize​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#Finalize","content":"&lt;/&gt; Writer.Finalize( self: WriterData-- A writer instance created with .new ) → buffer Creates a packet buffer from all queued operations in a single pass  ","version":null,"tagName":"h3"},{"title":"new​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#new","content":"Constructor &lt;/&gt; Writer.new() → WriterData Creates an empty writer instance ","version":null,"tagName":"h3"},{"title":"Installation","type":0,"sectionRef":"#","url":"/Pack/docs/Installation","content":"","keywords":"","version":"Next"},{"title":"Wally​","type":1,"pageTitle":"Installation","url":"/Pack/docs/Installation#wally","content":" Get the latest version of Pack from wally.run and add it to your wally.toml  For best results, you will need to run wally-package-types for the needed internal types to be exported. Without doing this, you will not have access to the Pack.Schema type needed to use tuple schemas.  ","version":"Next","tagName":"h2"},{"title":"Manual​","type":1,"pageTitle":"Installation","url":"/Pack/docs/Installation#manual","content":" Download the latest version of Pack from releases and insert it somewhere in ReplicatedStorage. ","version":"Next","tagName":"h2"},{"title":"Welcome to Pack","type":0,"sectionRef":"#","url":"/Pack/docs/intro","content":"Welcome to Pack TODO","keywords":"","version":"Next"},{"title":"Primitive Datatypes","type":0,"sectionRef":"#","url":"/Pack/docs/Datatypes/Primitives","content":"","keywords":"","version":"Next"},{"title":"Any​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#any","content":" The Any datatype attempts to automatically encode any value inserted, at the cost of a much higher overhead. Currently, Any has few optimizations for tables, treating them all as arrays of any when possible (1 byte overhead for each value), otherwise falling back to a map of [any]: any (2 bytes of overhead for each key-value pair) and does not support metatables or functions.  ","version":"Next","tagName":"h2"},{"title":"BitField​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#bitfield","content":" A BitField is a highly compressed array of booleans, using bit packing to fit eight booleans into one byte, instead of the usual one. To use this datatype, you must pass in a fixed length of how many booleans it is expected to store. When writing to this datatype, it is in the format of an array of booleans. If the array is shorter than the expected length, the last values will be treated as false. Reading it will return the array of booleans in the same order.  info You should try to have the defined length as close to a multiple of eight as possible. If your bitfield length is a mutliple of 8 (including 0) + 1, use a regular boolean for that last bool instead.  ","version":"Next","tagName":"h2"},{"title":"Boolean​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#boolean","content":" Encodes a true/false value into a single byte.  ","version":"Next","tagName":"h2"},{"title":"BrickColor​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#brickcolor","content":" Encodes a BrickColor value in 2 bytes.  ","version":"Next","tagName":"h2"},{"title":"BufferFixed​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#bufferfixed","content":" BufferFixed refers a fixed length buffer, where a buffer of a known length will encoded with zero overhead. The fixed length of the buffer in bytes must be passed in.  ","version":"Next","tagName":"h2"},{"title":"Buffer8​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#buffer8","content":" Encodes a buffer of variable length between 0 and 255 bytes with 1 byte of overhead.  ","version":"Next","tagName":"h2"},{"title":"Buffer16​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#buffer16","content":" Encodes a buffer of variable length between 0 and 65,535 bytes with 2 bytes of overhead.  ","version":"Next","tagName":"h2"},{"title":"Buffer24​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#buffer24","content":" Encodes a buffer of variable length between 0 and 16 MiB with 3 bytes of overhead.  ","version":"Next","tagName":"h2"},{"title":"Buffer32​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#buffer32","content":" Encodes a buffer of any length with 4 bytes of overhead. The maximum length with a buffer32 is greater than the 1 GiB size limit of buffers.  ","version":"Next","tagName":"h2"},{"title":"CFrame​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#cframe","content":" Encodes a CFrame as either 13 or 19 bytes. A standard Vector3 is used for position. Axis-Aligned CFrames are 13 bytes, otherwise for random orientation CFrames they are encoded in 19 bytes using a Quaternion for rotation, with an average percision of 0.00461° (more than enough).  ","version":"Next","tagName":"h2"},{"title":"Color3​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#color3","content":" Encodes a Color3 value as standard 24-bit RGB in 3 bytes.  note The Color3 Datatype actually uses 32 bit floats to store RGB, meaning sometimes colors will have RGB values above 255. If this is necessary, use Color3float32 instead  ","version":"Next","tagName":"h2"},{"title":"Color3float32​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#color3float32","content":" Enodes a Color3 value in full using 12 bytes. This is for when you have colors with RGB values above 255.  ","version":"Next","tagName":"h2"},{"title":"DateTime​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#datetime","content":" Encodes a DateTime with millisecond percision using 8 bytes.  ","version":"Next","tagName":"h2"},{"title":"EnumItem​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#enumitem","content":" Encodes an EnumItem from a provided Roblox Enum using between 1 and 2 bytes. Some common Enums such as Material and KeyCode use 2 bytes due to how these Enums were set up (they have items with values going past 255)  -- Pass in which Enum you are using Pack:DefineSchema(Pack.EnumItem(Enum.KeyCode))   ","version":"Next","tagName":"h2"},{"title":"Float16​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#float16","content":" Encodes a 16-bit floating point number using 2 bytes  Range:  Subnormal: ±6.1×10⁻⁵Normal: ±6.5×10⁴ Precision: ~3.3 decimal places  ","version":"Next","tagName":"h2"},{"title":"Float24​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#float24","content":" Encodes a 24-bit floating point number using 3 bytes  Range:  Subnormal: ±1×10⁻¹⁹Normal: ±2×10¹⁹ Precision: ~5.9 decimal places  ","version":"Next","tagName":"h2"},{"title":"Float32​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#float32","content":" Aliases Float is an alias for Float32 and can be used instead  Encodes a 32-bit floating point number using 4 bytes  Range:  Subnormal: ±1.2×10⁻³⁸Normal: ±3.4×10³⁸ Precision: ~7.2 decimal places  ","version":"Next","tagName":"h2"},{"title":"Float64​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#float64","content":" Aliases Double is an alias for Float64 and can be used instead  Enocdes a 64-bit floating point number using 8 bytes. This is the type used by lua numbers. It is also the only numeric type that can be used for UserIds, as those have passed the 32-bit unsigned integer limit.  Range:  Subnormal: ±2.2×10⁻³⁰⁸Normal: ±1.8×10³⁰⁸ Precision: ~15.9 decimal places  ","version":"Next","tagName":"h2"},{"title":"Instance​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#instance","content":" Encodes a reference to an Instance. This will place a UID tag on the instance so it can be located later. This UID is 4 bytes. Note that the UID tag is not removed, as  warning This reference does not persist between server and client WRITE UNSAFE Writing a reference to an Instance that does not already have a UID will synchronize the thread  In saving places, references persist between server runtimes.  ","version":"Next","tagName":"h2"},{"title":"Int8​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#int8","content":" Aliases Byte is an alias for Int8 and can be used instead  Enocdes an 8-bit signed integer in a single byte. Range: -128 – 127  ","version":"Next","tagName":"h2"},{"title":"Int16​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#int16","content":" Aliases Short is an alias for Int16 and can be used instead  Encodes a 16-bit signed integer in 2 bytes. Range: -32,768 – 32,767  ","version":"Next","tagName":"h2"},{"title":"Int32​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#int32","content":" Aliases Int is an alias for Int32 and can be used instead  Encodes a 32-bit signed integer in 4 bytes. Range: -2,147,483,648 – 2,147,483,647  ","version":"Next","tagName":"h2"},{"title":"Null​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#null","content":" Represents nothing, directly uses zero bytes. For use in the Union structure (WIP)  ","version":"Next","tagName":"h2"},{"title":"Object​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#object","content":" Allows marshalling a lua object by providing the class's metatable, and a Dictionary of members to serialize from the object. This should work for most common OOP patterns. An example has been provided for the classic lua OOP paradigm.  -- Example Class -- local exampleClass = {} exampleClass.__index = exampleClass function exampleClass:SomeMethod(val: number) self.someProperty = val end function exampleClass.new(val: number) local self = setmetatable({}, exampleClass) self.someProperty = val return self end ---- -- Create a schema to marshall exampleClass by providing its metatable -- as well as instructions to serialize its properties local schema = Pack:DefineSchema(Pack.object(getmetatable(exampleClass), Pack.Dictionary({ someProperty = Pack.Double }))) ---- -- Test it with an object of exampleClass local exampleObject = exampleClass.new(1) print(exampleObject.someProperty) -- &gt;&gt;&gt; 1 exampleObject:SomeMethod(10) print(exampleObject.someProperty) -- &gt;&gt;&gt; 10 local reconstructedObject = schema:Read(schema:Write(exampleObject)) print(reconstructedObject.someProperty) -- &gt;&gt;&gt; 10 reconstructedObject:SomeMethod(100) print(reconstructedObject.someProperty) -- &gt;&gt;&gt; 100   ","version":"Next","tagName":"h2"},{"title":"Region3​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#region3","content":" Encodes a Region3 as a min and max Vector3, giving a total of 24 bytes.  ","version":"Next","tagName":"h2"},{"title":"Region3int16​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#region3int16","content":" Encodes a Region3int16 as a min and max Vector3int16, giving a total of 12 bytes.  ","version":"Next","tagName":"h2"},{"title":"StringFixed​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#stringfixed","content":" StringFixed refers a fixed length string, where a string of a known length will encoded with zero overhead. The fixed length of the string in bytes must be passed in.  ","version":"Next","tagName":"h2"},{"title":"String8​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#string8","content":" Encodes a string of variable length between 0 and 255 bytes with 1 byte of overhead. Chars already have a variable length of 1-4, so this can range from 255 chars to 63 chars.  ","version":"Next","tagName":"h2"},{"title":"String16​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#string16","content":" Encodes a string of variable length between 0 and 65,535 bytes with 2 bytes of overhead. Chars already have a variable length of 1-4, so this can range from 65,535 chars to 16,383 chars.  ","version":"Next","tagName":"h2"},{"title":"String24​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#string24","content":" Encodes a string of variable length between 0 and 16 MiB with 3 bytes of overhead.  ","version":"Next","tagName":"h2"},{"title":"String32​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#string32","content":" Encodes a string of any length with 4 bytes of overhead. The maximum length with a string32 is bigger than the 1 GiB size limit of buffers.  ","version":"Next","tagName":"h2"},{"title":"UDim​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#udim","content":" Encodes a single UDim as 6 bytes. We assume the offset will be within the range of a int16. If this is not the case, you will have to send the UDim as a float32 scale and int32 offset.  ","version":"Next","tagName":"h2"},{"title":"UDim2​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#udim2","content":" Encodes a UDim2 as 12 bytes. We assume the offset will be within the range of a int16. If this is not the case, you will have to send the two UDims as a float32 scale and int32 offset.  ","version":"Next","tagName":"h2"},{"title":"UInt8​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#uint8","content":" Aliases UByte is an alias for UInt8 and can be used instead  Enocdes an 8-bit unsigned integer in a single byte. Range: 0 – 255  ","version":"Next","tagName":"h2"},{"title":"UInt16​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#uint16","content":" Aliases UShort is an alias for UInt16 and can be used instead  Encodes a 16-bit unsigned integer in 2 bytes. Range: 0 – 65,565  ","version":"Next","tagName":"h2"},{"title":"UInt32​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#uint32","content":" Aliases UInt is an alias for UInt32 and can be used instead  Encodes a 32-bit unsigned integer in 4 bytes. Range: 0 – 4,294,967,295  ","version":"Next","tagName":"h2"},{"title":"Vector2float32​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#vector2float32","content":" Aliases Vector2 is an alias for Vector2float32 and can be used instead  Encodes a 2D vector of float32s using 8 bytes.  see Float32 for approximate range and precision of each component.  ","version":"Next","tagName":"h2"},{"title":"Vector2float64​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#vector2float64","content":" Encodes a 2D vector of float64s using 16 bytes.  see Float64 for approximate range and precision of each component.  ","version":"Next","tagName":"h2"},{"title":"Vector2float24​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#vector2float24","content":" Encodes a 2D vector of float24s using 6 bytes.  see Float24 for approximate range and precision of each component.  ","version":"Next","tagName":"h2"},{"title":"Vector2float16​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#vector2float16","content":" Encodes a 2D vector of float16s with 4 bytes.  see Float16 for approximate range and precision of each component.  ","version":"Next","tagName":"h2"},{"title":"Vector2int16​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#vector2int16","content":" Encodes a 2D vector of int16s using 4 bytes.  ","version":"Next","tagName":"h2"},{"title":"Vector3float32​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#vector3float32","content":" Aliases Vector3 is an alias for Vector3float32 and can be used instead  Encodes a 3D vector of float32s using 12 bytes.  see Float32 for approximate range and precision of each component.  note Compatible with the Roblox Vector3 library and luau vector library. Will return as a luau vector, but these are interchangeable with the Vector3 library. (Vector3 methods can be used on vectors and vector library functions can take Vector3s)  ","version":"Next","tagName":"h2"},{"title":"Vector3float64​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#vector3float64","content":" Encodes a 3D vector of float64s using 24 bytes.  see Float64 for approximate range and precision of each component.  ","version":"Next","tagName":"h2"},{"title":"Vector3float24​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#vector3float24","content":" Encodes a 3D vector of float24s using 9 bytes.  see Float24 for approximate range and precision of each component.  ","version":"Next","tagName":"h2"},{"title":"Vector3float16​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#vector3float16","content":" Encodes a 3D vector of float16s with 6 bytes.  see Float16 for approximate range and precision of each component.  ","version":"Next","tagName":"h2"},{"title":"Vector3int16​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#vector3int16","content":" Encodes a 3D vector of int16s with 6 bytes. ","version":"Next","tagName":"h2"},{"title":"Reader","type":0,"sectionRef":"#","url":"/Pack/api/Reader","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#functions","content":" ","version":null,"tagName":"h2"},{"title":"moveCursor​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#moveCursor","content":"&lt;/&gt; Reader.moveCursor( self: ReaderData,-- A reader instance created with .new delta: number-- How many bytes to move the cursor, can be negative to go backwards ) → () Manually moves the reader's cursor. DANGER Does not prevent you from leaving buffer bounds.  ","version":null,"tagName":"h3"},{"title":"u8​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#u8","content":"&lt;/&gt; Reader.u8( self: ReaderData-- A reader instance created with .new ) → number Reads an unsigned 8-bit integer from the buffer and moves the cursor forwards 1 byte.  ","version":null,"tagName":"h3"},{"title":"u16​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#u16","content":"&lt;/&gt; Reader.u16( self: ReaderData-- A reader instance created with.new ) → number Reads an unsigned 16-bit integer from the buffer and moves the cursor forwards 2 bytes.  ","version":null,"tagName":"h3"},{"title":"u32​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#u32","content":"&lt;/&gt; Reader.u32( self: ReaderData-- A reader instance created with .new ) → number Reads an unsigned 32-bit integer from the buffer and moves the cursor forwards 4 bytes.  ","version":null,"tagName":"h3"},{"title":"u8​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#u8","content":"&lt;/&gt; Reader.u8( self: ReaderData-- A reader instance created with .new ) → number Reads a signed 8-bit integer from the buffer and moves the cursor forwards 1 byte.  ","version":null,"tagName":"h3"},{"title":"i16​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#i16","content":"&lt;/&gt; Reader.i16( self: ReaderData-- A reader instance created with .new ) → number Reads a signed 16-bit integer from the buffer and moves the cursor forwards 2 bytes.  ","version":null,"tagName":"h3"},{"title":"i32​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#i32","content":"&lt;/&gt; Reader.i32( self: ReaderData-- A reader instance created with .new ) → number Reads a signed 32-bit integer from the buffer and moves the cursor forwards 4 bytes.  ","version":null,"tagName":"h3"},{"title":"nBitUint​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#nBitUint","content":"&lt;/&gt; Reader.nBitUint( self: ReaderData,-- A reader instance created with .new n: number,-- The length in bits of the integer bitOffset: number-- The bit offset from the current cursor location [0 – 31] ) → number Reads an unsigned integer of length n bits INFO This function does not move the cursor after completing, so you will have to move it yourself with .moveCursor  ","version":null,"tagName":"h3"},{"title":"nBitInt​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#nBitInt","content":"&lt;/&gt; Reader.nBitInt( self: ReaderData,-- A reader instance created with .new n: number,-- The length in bits of the integer bitOffset: number-- The bit offset from the current cursor location [0 – 31] ) → number Reads a signed integer of length n bits INFO This function does not move the cursor after completing, so you will have to move it yourself with .moveCursor  ","version":null,"tagName":"h3"},{"title":"nBitFloat​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#nBitFloat","content":"&lt;/&gt; Reader.nBitFloat( self: ReaderData,-- A reader instance created with .new n: number,-- The length in bits of the floating point's exponent m: number,-- The length in bits of the floating point's mantissa bitOffset: number-- The bit offset from the current cursor location [0 – 31] ) → number Reads a custom signed floating point number with the exponent length n bits and mantissa length m bits INFO This function does not move the cursor after completing, so you will have to move it yourself with .moveCursor WARNING The sum of n and m should not be greater than 31 - bitOffset.  ","version":null,"tagName":"h3"},{"title":"f32​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#f32","content":"&lt;/&gt; Reader.f32( self: ReaderData-- A reader instance created with .new ) → number Reads a 32-bit floating point number from the buffer and moves the cursor forwards 4 bytes.  ","version":null,"tagName":"h3"},{"title":"f64​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#f64","content":"&lt;/&gt; Reader.f64( self: ReaderData-- A reader instance created with .new ) → number Reads a 64-bit floating point number from the buffer and moves the cursor forwards 8 bytes.  ","version":null,"tagName":"h3"},{"title":"string​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#string","content":"&lt;/&gt; Reader.string( self: ReaderData,-- A reader instance created with .new count: number-- The length of the string in bytes ) → string Reads a string of length count bytes from the buffer and pushes the cursor count bytes forwards.  ","version":null,"tagName":"h3"},{"title":"new​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#new","content":"Constructor &lt;/&gt; Reader.new( packet: buffer-- The packet the reader should be reading ) → ReaderData Creates a new reader instance from a written packet ","version":null,"tagName":"h3"}],"options":{"id":"default"}}