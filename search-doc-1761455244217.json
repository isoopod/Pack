{"searchDocs":[{"title":"Datatype","type":0,"sectionRef":"#","url":"/Pack/api/Datatype","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Datatype","url":"/Pack/api/Datatype#types","content":" ","version":null,"tagName":"h2"},{"title":"DatatypeInterface<T>​","type":1,"pageTitle":"Datatype","url":"/Pack/api/Datatype#DatatypeInterface<T>","content":"&lt;/&gt; type DatatypeInterface&lt;T&gt; = { Eval: string?, Len: number?, BitLen: number?, Read: (ReaderData) → T, Write: ( writer: WriterData, value: T ) → () } Eval is a string indicating which evaluator to use for this value if applicable. Extra info can be added regarding this for advanced datatypes. Read is a function that is passed a ReaderData instance and expected to read the ReaderData and return whatever was passed into Write. Write is a function that is passed a WriterData instance and a value and is expected to write the value into WriterData. ","version":null,"tagName":"h3"},{"title":"Evaluator","type":0,"sectionRef":"#","url":"/Pack/api/Evaluator","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Evaluator","url":"/Pack/api/Evaluator#functions","content":" ","version":null,"tagName":"h2"},{"title":"addEvaluator​","type":1,"pageTitle":"Evaluator","url":"/Pack/api/Evaluator#addEvaluator","content":"&lt;/&gt; Evaluator.addEvaluator( Eval: string,-- The name of the evaluator. (Same as the Eval field in your datatype) func: ( value: any, datatype: types.DatatypeInterface&lt;any&gt; ) → boolean-- The evaluator function. ) → () Adds a new evaluator function to the evaluator table. Use this to add support for custom datatypes inside Unions. ","version":null,"tagName":"h3"},{"title":"BitReader","type":0,"sectionRef":"#","url":"/Pack/api/BitReader","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"BitReader","url":"/Pack/api/BitReader#functions","content":" ","version":null,"tagName":"h2"},{"title":"moveCursor​","type":1,"pageTitle":"BitReader","url":"/Pack/api/BitReader#moveCursor","content":"&lt;/&gt; BitReader.moveCursor( delta: number-- Number of bits to move the cursor by. ) → () Moves the read cursor to the left by the specified number of bits without reading. Used to skip over unused or reserved sections of the bit buffer.  ","version":null,"tagName":"h3"},{"title":"read​","type":1,"pageTitle":"BitReader","url":"/Pack/api/BitReader#read","content":"&lt;/&gt; BitReader.read( bits: number-- Number of bits to read. ) → number-- The value read from the buffer. Reads a value from the buffer by consuming the specified number of bits from right to left. ","version":null,"tagName":"h3"},{"title":"BitWriter","type":0,"sectionRef":"#","url":"/Pack/api/BitWriter","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"BitWriter","url":"/Pack/api/BitWriter#functions","content":" ","version":null,"tagName":"h2"},{"title":"alloc​","type":1,"pageTitle":"BitWriter","url":"/Pack/api/BitWriter#alloc","content":"&lt;/&gt; BitWriter.alloc( self: WriterData,-- A writer instance created with .new bits: number-- Number of bits to allocate. ) → () Allocates space in the internal bit buffer without writing any values. This is used to reserve bits ahead of time.  ","version":null,"tagName":"h3"},{"title":"write​","type":1,"pageTitle":"BitWriter","url":"/Pack/api/BitWriter#write","content":"&lt;/&gt; BitWriter.write( self: WriterData,-- A writer instance created with .new bits: number,-- Number of bits to write. value: number-- Value to write into the buffer. ) → () Writes the given number of bits with the specified value. The value will be written from right to left in the finalised buffer.  ","version":null,"tagName":"h3"},{"title":"moveCursor​","type":1,"pageTitle":"BitWriter","url":"/Pack/api/BitWriter#moveCursor","content":"&lt;/&gt; BitWriter.moveCursor( self: WriterData,-- A writer instance created with .new delta: number-- Number of bits to move the cursor by. ) → () Moves the write cursor left by the given number of bits without writing any data. Useful for padding or skipping reserved sections of the buffer.  ","version":null,"tagName":"h3"},{"title":"Finalize​","type":1,"pageTitle":"BitWriter","url":"/Pack/api/BitWriter#Finalize","content":"&lt;/&gt; BitWriter.Finalize( self: WriterData-- A writer instance created with .new ) → () Finalises the bit buffer and writes into the provided binary buffer. Executes all queued write and cursor move operations from right to left. ","version":null,"tagName":"h3"},{"title":"Schema","type":0,"sectionRef":"#","url":"/Pack/api/Schema","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"Schema","url":"/Pack/api/Schema#properties","content":" ","version":null,"tagName":"h2"},{"title":"DisableReadProtection​","type":1,"pageTitle":"Schema","url":"/Pack/api/Schema#DisableReadProtection","content":"&lt;/&gt; Schema.DisableReadProtection: boolean? If true, disables the read protection that checks if the entire packet was read. This is not recommended unless you have a specific use case that requires it. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Schema","url":"/Pack/api/Schema#functions","content":" ","version":null,"tagName":"h2"},{"title":"Write​","type":1,"pageTitle":"Schema","url":"/Pack/api/Schema#Write","content":"&lt;/&gt; Schema:Write(...: any) → ( buffer,-- This is your 'packet' that can be sent around or stored and later read by this schema. {any}?-- Table of refs for datatypes making use of this. Stock Pack does not use this and this is intended for Networking. ) Writes a packet (buffer) from the provided input, which should follow the structure of the schema.  ","version":null,"tagName":"h3"},{"title":"Read​","type":1,"pageTitle":"Schema","url":"/Pack/api/Schema#Read","content":"&lt;/&gt; Schema:Read( packet: buffer,-- A packet created by this schema with the Write method. refs: {any}?-- Optional table of refs for datatypes making use of this. Stock Pack does not use this and this is intended for Networking. ) → (...any)-- This is a reconstruction of the input to the packet. Reads a packet (buffer) that was written with the same schema and outputs a reconstruction of the packet's input. ","version":null,"tagName":"h3"},{"title":"Pack","type":0,"sectionRef":"#","url":"/Pack/api/Pack","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Pack","url":"/Pack/api/Pack#functions","content":" ","version":null,"tagName":"h2"},{"title":"Define​","type":1,"pageTitle":"Pack","url":"/Pack/api/Pack#Define","content":"&lt;/&gt; Pack:Define( ...: Datatype-- See all datatypes in Docs/Datatypes ) → Schema Defines a Schema from the provided datatypes. This supports tuples, however due to luau limitations you will need to manually annotate the type. local Pack = require(path.to.pack) -- The type of this schema will implicitly be infered as CFrame local exampleSchema = Pack:Define(Pack.CFrame) -- For tuples, you must explicitly annotate the type of the schema using Pack.Schema&lt;...&gt;. -- The luau type solver can only infer the first argument. local tupleSchema = Pack:Define(Pack.CFrame, Pack.Vector3) :: Pack.Schema&lt;CFrame, Vector3&gt;   ","version":null,"tagName":"h3"},{"title":"GetReader​","type":1,"pageTitle":"Pack","url":"/Pack/api/Pack#GetReader","content":"&lt;/&gt; Pack:GetReader() → Reader Returns the internal buffer reader library. Use this with Pack.Custom  ","version":null,"tagName":"h3"},{"title":"GetWriter​","type":1,"pageTitle":"Pack","url":"/Pack/api/Pack#GetWriter","content":"&lt;/&gt; Pack:GetWriter() → Writer Returns the internal buffer writer library. Use this with Pack.Custom  ","version":null,"tagName":"h3"},{"title":"GetBitReader​","type":1,"pageTitle":"Pack","url":"/Pack/api/Pack#GetBitReader","content":"&lt;/&gt; Pack:GetBitReader() → BitReader Returns the internal bitbuffer reader library. Use this with Pack.Custom  ","version":null,"tagName":"h3"},{"title":"GetBitWriter​","type":1,"pageTitle":"Pack","url":"/Pack/api/Pack#GetBitWriter","content":"&lt;/&gt; Pack:GetBitWriter() → BitWriter Returns the internal bitbuffer writer library. Use this with Pack.Custom  ","version":null,"tagName":"h3"},{"title":"GetConfig​","type":1,"pageTitle":"Pack","url":"/Pack/api/Pack#GetConfig","content":"&lt;/&gt; Pack:GetConfig() → {[any]: any} Returns the parsed pack configuration. This will be the same as the pack-config module if it is found, as the parser directly modifies that table. ","version":null,"tagName":"h3"},{"title":"Logger","type":0,"sectionRef":"#","url":"/Pack/api/Logger","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Logger","url":"/Pack/api/Logger#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Logger","url":"/Pack/api/Logger#new","content":"&lt;/&gt; Logger.new( prefix: string?-- Optional prefix for log lines. ) → Logger Creates a new Logger instance with an optional prefix.  ","version":null,"tagName":"h3"},{"title":"AddLine​","type":1,"pageTitle":"Logger","url":"/Pack/api/Logger#AddLine","content":"&lt;/&gt; Logger:AddLine( line: string-- The line to add to the log. ) → () Adds a line to the logger with the current prefix.  ","version":null,"tagName":"h3"},{"title":"Get​","type":1,"pageTitle":"Logger","url":"/Pack/api/Logger#Get","content":"&lt;/&gt; Logger:Get() → string-- The concatenated log lines. Retrieves the current log as a single string.  ","version":null,"tagName":"h3"},{"title":"Clear​","type":1,"pageTitle":"Logger","url":"/Pack/api/Logger#Clear","content":"&lt;/&gt; Logger:Clear() → () Clears all log lines.  ","version":null,"tagName":"h3"},{"title":"SetPrefix​","type":1,"pageTitle":"Logger","url":"/Pack/api/Logger#SetPrefix","content":"&lt;/&gt; Logger:SetPrefix( prefix: string-- The new prefix for log lines. ) → () Sets a new prefix for the logger.  ","version":null,"tagName":"h3"},{"title":"SetStatus​","type":1,"pageTitle":"Logger","url":"/Pack/api/Logger#SetStatus","content":"&lt;/&gt; Logger:SetStatus( status: number-- The status code (0: success, 1: warning, 2: error). ) → () Sets the status of the logger, allowing for different log levels.  ","version":null,"tagName":"h3"},{"title":"StackTrace​","type":1,"pageTitle":"Logger","url":"/Pack/api/Logger#StackTrace","content":"&lt;/&gt; Logger:StackTrace( start: number?-- Optional starting point for the stack trace. ) → () Logs the current stack trace starting from the specified point.  ","version":null,"tagName":"h3"},{"title":"WriteLogs​","type":1,"pageTitle":"Logger","url":"/Pack/api/Logger#WriteLogs","content":"&lt;/&gt; Logger:WriteLogs() → () Prints the logs to the console based on the status. If status is 0, it prints a message. If 1, it warns. If 2, it errors. ","version":null,"tagName":"h3"},{"title":"Configuration","type":0,"sectionRef":"#","url":"/Pack/docs/Configuration","content":"","keywords":"","version":"Next"},{"title":"pack-config.toml​","type":1,"pageTitle":"Configuration","url":"/Pack/docs/Configuration#pack-configtoml","content":" For Rojo users, directly under ReplicatedStorage you can create a pack-config.toml file to control Pack's behaviour. Below are all the settings used by Pack with their default values.  persistInstanceRefs = false # Are we making use of Pack.Instance in a place using AssetService:SavePlaceAsync()? This allows refs to persist between sessions. [debug] enabled = false onlyInStudio = true # Should debug only be enabled in studio? verbose = false # Do we want verbose output (not recommended)   Libraries built on top of Pack may implement their own settings, or borrow from these settings.  ","version":"Next","tagName":"h2"},{"title":"pack-config ModuleScript​","type":1,"pageTitle":"Configuration","url":"/Pack/docs/Configuration#pack-config-modulescript","content":" If you aren't using Rojo, we use a different format for the settings. Create a Module called pack-config in ReplicatedStorage.  -- See the corresponding entry in the pack-config.toml section for an explaination of the setting return { persistInstanceRefs = false, debug = { enabled = false, onlyInStudio = true, verbose = false }, }     note All entries of the pack-config TOML or module are optional. Booleans default to false unless otherwise stated. ","version":"Next","tagName":"h2"},{"title":"Reader","type":0,"sectionRef":"#","url":"/Pack/api/Reader","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#functions","content":" ","version":null,"tagName":"h2"},{"title":"moveCursor​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#moveCursor","content":"&lt;/&gt; Reader.moveCursor( self: ReaderData,-- A reader instance created with .new delta: number-- How many bytes to move the cursor, can be negative to go backwards ) → () Manually moves the reader's cursor. DANGER Does not prevent you from leaving buffer bounds.  ","version":null,"tagName":"h3"},{"title":"u8​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#u8","content":"&lt;/&gt; Reader.u8( self: ReaderData-- A reader instance created with .new ) → number Reads an unsigned 8-bit integer from the buffer and moves the cursor forwards 1 byte.  ","version":null,"tagName":"h3"},{"title":"u16​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#u16","content":"&lt;/&gt; Reader.u16( self: ReaderData-- A reader instance created with.new ) → number Reads an unsigned 16-bit integer from the buffer and moves the cursor forwards 2 bytes.  ","version":null,"tagName":"h3"},{"title":"u32​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#u32","content":"&lt;/&gt; Reader.u32( self: ReaderData-- A reader instance created with .new ) → number Reads an unsigned 32-bit integer from the buffer and moves the cursor forwards 4 bytes.  ","version":null,"tagName":"h3"},{"title":"u8​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#u8","content":"&lt;/&gt; Reader.u8( self: ReaderData-- A reader instance created with .new ) → number Reads a signed 8-bit integer from the buffer and moves the cursor forwards 1 byte.  ","version":null,"tagName":"h3"},{"title":"i16​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#i16","content":"&lt;/&gt; Reader.i16( self: ReaderData-- A reader instance created with .new ) → number Reads a signed 16-bit integer from the buffer and moves the cursor forwards 2 bytes.  ","version":null,"tagName":"h3"},{"title":"i32​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#i32","content":"&lt;/&gt; Reader.i32( self: ReaderData-- A reader instance created with .new ) → number Reads a signed 32-bit integer from the buffer and moves the cursor forwards 4 bytes.  ","version":null,"tagName":"h3"},{"title":"nBitUint​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#nBitUint","content":"&lt;/&gt; Reader.nBitUint( self: ReaderData,-- A reader instance created with .new n: number,-- The length in bits of the integer bitOffset: number-- The bit offset from the current cursor location [0 – 31] ) → number Reads an unsigned integer of length n bits INFO This function does not move the cursor after completing, so you will have to move it yourself with .moveCursor  ","version":null,"tagName":"h3"},{"title":"nBitInt​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#nBitInt","content":"&lt;/&gt; Reader.nBitInt( self: ReaderData,-- A reader instance created with .new n: number,-- The length in bits of the integer bitOffset: number-- The bit offset from the current cursor location [0 – 31] ) → number Reads a signed integer of length n bits INFO This function does not move the cursor after completing, so you will have to move it yourself with .moveCursor  ","version":null,"tagName":"h3"},{"title":"nBitFloat​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#nBitFloat","content":"&lt;/&gt; Reader.nBitFloat( self: ReaderData,-- A reader instance created with .new n: number,-- The length in bits of the floating point's exponent m: number,-- The length in bits of the floating point's mantissa bitOffset: number-- The bit offset from the current cursor location [0 – 31] ) → number Reads a custom signed floating point number with the exponent length n bits and mantissa length m bits INFO This function does not move the cursor after completing, so you will have to move it yourself with .moveCursor WARNING The sum of n and m should not be greater than 31 - bitOffset.  ","version":null,"tagName":"h3"},{"title":"f32​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#f32","content":"&lt;/&gt; Reader.f32( self: ReaderData-- A reader instance created with .new ) → number Reads a 32-bit floating point number from the buffer and moves the cursor forwards 4 bytes.  ","version":null,"tagName":"h3"},{"title":"f64​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#f64","content":"&lt;/&gt; Reader.f64( self: ReaderData-- A reader instance created with .new ) → number Reads a 64-bit floating point number from the buffer and moves the cursor forwards 8 bytes.  ","version":null,"tagName":"h3"},{"title":"string​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#string","content":"&lt;/&gt; Reader.string( self: ReaderData,-- A reader instance created with .new count: number-- The length of the string in bytes ) → string Reads a string of length count bytes from the buffer and pushes the cursor count bytes forwards.  ","version":null,"tagName":"h3"},{"title":"new​","type":1,"pageTitle":"Reader","url":"/Pack/api/Reader#new","content":"Constructor &lt;/&gt; Reader.new( packet: buffer-- The packet the reader should be reading ) → ReaderData Creates a new reader instance from a written packet ","version":null,"tagName":"h3"},{"title":"Writer","type":0,"sectionRef":"#","url":"/Pack/api/Writer","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#functions","content":" ","version":null,"tagName":"h2"},{"title":"alloc​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#alloc","content":"&lt;/&gt; Writer.alloc( self: WriterData,-- A writer instance created with .new bytes: number-- The number of bytes to allocate ) → () Most Writer functions will not automatically allocate length to the buffer, instead opting to make this call as few times as possible when writing a datatype. Functions that do allocate will be marked with the Allocating tag. Otherwise, figure out how many bytes you need to allocate and call Writer.alloc  ","version":null,"tagName":"h3"},{"title":"u8​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#u8","content":"&lt;/&gt; Writer.u8( self: WriterData,-- A writer instance created with .new value: number ) → () 1 byte Writes an 8-bit unsigned integer into the packet  ","version":null,"tagName":"h3"},{"title":"u16​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#u16","content":"&lt;/&gt; Writer.u16( self: WriterData,-- A writer instance created with .new value: number ) → () 2 bytes Writes a 16-bit unsigned integer into the packet  ","version":null,"tagName":"h3"},{"title":"u32​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#u32","content":"&lt;/&gt; Writer.u32( self: WriterData,-- A writer instance created with .new value: number ) → () 4 bytes Writes a 32-bit unsigned integer into the packet  ","version":null,"tagName":"h3"},{"title":"i8​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#i8","content":"&lt;/&gt; Writer.i8( self: WriterData,-- A writer instance created with .new value: number ) → () 1 bytes Writes an 8-bit signed integer into the packet  ","version":null,"tagName":"h3"},{"title":"i16​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#i16","content":"&lt;/&gt; Writer.i16( self: WriterData,-- A writer instance created with .new value: number ) → () 2 bytes Writes a 16-bit signed integer into the packet  ","version":null,"tagName":"h3"},{"title":"i32​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#i32","content":"&lt;/&gt; Writer.i32( self: WriterData,-- A writer instance created with .new value: number ) → () 4 bytes Writes a 32-bit signed integer into the packet  ","version":null,"tagName":"h3"},{"title":"nBitUint​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#nBitUint","content":"&lt;/&gt; Writer.nBitUint( self: WriterData,-- A writer instance created with .new value: number, n: number,-- The length of the integer in bits bitOffset: number-- The offset from the cursor in bits to start writing at [0 – 31] ) → () math.floor(n / 8) + 1 bytes Writes an unsigned n-bit integer into the packet INFO nBitUint does not automatically move the writers cursor so you will have to call Writer.moveCursor the appropriate number of bytes after writing a section of nBit numbers.  ","version":null,"tagName":"h3"},{"title":"nBitInt​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#nBitInt","content":"&lt;/&gt; Writer.nBitInt( self: WriterData,-- A writer instance created with .new value: number, n: number,-- The length of the integer in bits bitOffset: number-- The offset from the cursor in bits to start writing at [0 – 31] ) → () math.floor(n / 8) + 1 bytes Writes a signed n-bit integer into the packet INFO nBitInt does not automatically move the writers cursor so you will have to call Writer.moveCursor the appropriate number of bytes after writing a section of nBit numbers.  ","version":null,"tagName":"h3"},{"title":"nBitFloat​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#nBitFloat","content":"&lt;/&gt; Writer.nBitFloat( self: WriterData,-- A writer instance created with .new value: number, n: number,-- The length in bits of the floating point's exponent m: number,-- The length in bits of the floating point's mantissa bitOffset: number-- The offset from the cursor in bits to start writing at [0 – 31] ) → () math.floor((1 + n + m) / 8) + 1 bytes Writes a floating point number into the packet INFO nBitFloat does not automatically move the writer's cursor so you will have to call Writer.moveCursor the appropriate number of bytes after writing a section of nBit numbers. WARNING The sum of n and m should not be greater than 31 - bitOffset.  ","version":null,"tagName":"h3"},{"title":"f32​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#f32","content":"&lt;/&gt; Writer.f32( self: WriterData,-- A writer instance created with .new value: number ) → () 4 bytes Writes a 32-bit floating point number into the packet  ","version":null,"tagName":"h3"},{"title":"f64​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#f64","content":"&lt;/&gt; Writer.f64( self: WriterData,-- A writer instance created with .new value: number ) → () 8 bytes Writes a 64-bit floating point number into the packet  ","version":null,"tagName":"h3"},{"title":"string​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#string","content":"Allocating &lt;/&gt; Writer.string( self: WriterData,-- A writer instance created with .new value: string,-- The string you wish to write count: number?-- Optional value denoting the maximum number of bytes to write ) → ( number,-- the length of the string in bytes () → ()-- A function that orders the wring into the packet ) Processes a string into a seperate buffer and allocates the byte length of the string (or if count is provided and smaller than blen, allocates count bytes) Returns the amount of bytes allocated, and a function to commit the string to the packet. This is so the length of the string can be written before writing the string itself, for variable length strings.  ","version":null,"tagName":"h3"},{"title":"stringFixed​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#stringFixed","content":"&lt;/&gt; Writer.stringFixed( self: WriterData,-- A writer instance created with .new value: string,-- The string you wish to write count: number?-- Optional value denoting the maximum number of bytes to write ) → () When we already know the length of the string, we can write it directly to the buffer without needing to  ","version":null,"tagName":"h3"},{"title":"moveCursor​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#moveCursor","content":"&lt;/&gt; Writer.moveCursor( self: WriterData,-- A writer instance created with .new delta: number-- How many bytes to move the cursor, can be negative to go backwards ) → () Manually moves the writer's cursor. DANGER Does not prevent you from leaving buffer bounds.  ","version":null,"tagName":"h3"},{"title":"Finalize​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#Finalize","content":"&lt;/&gt; Writer.Finalize( self: WriterData-- A writer instance created with .new ) → buffer Finalizes the packet by writing the bit buffer and trimming the main buffer to the correct size.  ","version":null,"tagName":"h3"},{"title":"new​","type":1,"pageTitle":"Writer","url":"/Pack/api/Writer#new","content":"Constructor &lt;/&gt; Writer.new( approxLen: number?,-- Optional approximate length of the buffer to be created. This is used to preallocate the buffer size so less resizes are needed. approxBitLen: number?-- Optional approximate length of the bit buffer to be created. This is used to preallocate the bit buffer size so less resizes are needed. ) → WriterData Creates an empty writer instance ","version":null,"tagName":"h3"},{"title":"Miscellaneous Datatypes","type":0,"sectionRef":"#","url":"/Pack/docs/Datatypes/Miscellaneous","content":"","keywords":"","version":"Next"},{"title":"Custom​","type":1,"pageTitle":"Miscellaneous Datatypes","url":"/Pack/docs/Datatypes/Miscellaneous#custom","content":" Pack.Custom(reader: (reader) -&gt; T, writer: (writer, val: T))   The Custom datatype is used as a simple way to create a custom datatype that will be used once. If performance is essential or the datatype needs to be reused, you can create an extension datatype using the exposed internal Pack types.  -- See the API reference for the Reader and Writer libraries. -- In this example, the datatype just represents a float64 local Reader = Pack:GetReader() local Writer = Pack:GetWriter() Pack:DefineSchema( Pack.Custom( function(reader) return Reader.f64(reader) end, function(writer, val: number) Writer.alloc(writer, 4) Writer.f64(writer, val) end ) )   ","version":"Next","tagName":"h2"},{"title":"Transformer​","type":1,"pageTitle":"Miscellaneous Datatypes","url":"/Pack/docs/Datatypes/Miscellaneous#transformer","content":" Pack.Transformer(format: T, encode: ((input: U) -&gt; T)?, decode: ((input: T) -&gt; U)?)   The Transformer datatype functions as a convenient wrapper for transforming raw data into a more efficient format for encoding, and reversing that process. The format (usually a Dictionary) is how the data will be encoded by Pack. The encode function should take some data not that would not directly be accepted by format and transform it such that it can be. The decode function would then bring data encoded in that format and turn it back into the original format  encode and decode are both optional, allowing you to use the transformer for data normalization, such as filling in defaults.  type standard = { color: string -- Hex string enabled: &quot;True&quot; | &quot;False&quot; } Pack:DefineSchema( Pack.Transformer( Pack.Dicitonary({ color = Pack.Color3, enabled = Pack.Boolean, }), function(input: standard) local result = {} result.color = Color3.FromHex(input.color) result.enabled = input.enabled == &quot;True&quot; return result end, function(input) -- The type should be inferred as the same type as the dictionary local result = {} result.color = input.color:ToHex() result.enabled = input.enabled and &quot;True&quot; or &quot;False return result end ) )  ","version":"Next","tagName":"h2"},{"title":"Structural Datatypes","type":0,"sectionRef":"#","url":"/Pack/docs/Datatypes/Structures","content":"","keywords":"","version":"Next"},{"title":"Array​","type":1,"pageTitle":"Structural Datatypes","url":"/Pack/docs/Datatypes/Structures#array","content":" Pack.Array(datatype: Datatype&lt;any&gt;, lengthType: Datatype&lt;number&gt;?)   An Array is an ordered collection of values with the same type. Arrays are one-based for consistency with lua. Arrays have two bytes of overhead and can contain a maximum of 65,565 elements by deafult. The type of number the Array uses to encode the length can be changed with the second argument and should be an unsigned integer. By default this is UInt16.  ","version":"Next","tagName":"h2"},{"title":"Dictionary​","type":1,"pageTitle":"Structural Datatypes","url":"/Pack/docs/Datatypes/Structures#dictionary","content":" Pack.Dictionary(format: { [any]: Datatype&lt;any&gt; })   A Pack Dictionary refers to a table with predefined keys. This is sometimes called a struct in similar libraries. Dictionaries add no overhead.  Pack:DefineSchema(Pack.Dictionary({ -- Doesn't matter which way you assign string keys [&quot;A&quot;] = Pack.Float64, B = Pack.Float32, -- You aren't limited to just strings as the key. -- Beware that using non-string keys may break the typing, and explicit type annotation may not be able to fix it. [0] = Pack.CFrame, -- You can nest Dictionaries and use other structural datatypes inside a dictionary Nested = Pack.Dictionary({ A = Pack.String16, }), }))   ","version":"Next","tagName":"h2"},{"title":"Map​","type":1,"pageTitle":"Structural Datatypes","url":"/Pack/docs/Datatypes/Structures#map","content":" Pack.Map(keyType: Datatype&lt;any&gt;, valueType: Datatype&lt;any&gt;, lengthType: Datatype&lt;number&gt;?)   A Map is a mapping of some type of key to some type of value. This is very useful when used with the Union or any datatypes. Maps have two bytes of overhead and can contain a maximum of 65,565 elements by deafult. The type of number the Map uses to encode the length can be changed with the second argument and should be an unsigned integer. By default this is UInt16.  ","version":"Next","tagName":"h2"},{"title":"Nullable​","type":1,"pageTitle":"Structural Datatypes","url":"/Pack/docs/Datatypes/Structures#nullable","content":" Pack.Nullable(datatype: Datatype&lt;any&gt;)   The Nullable datatype indicates the value is optional and may be nil. This adds 1 bit of overhead for every nullable value.  ","version":"Next","tagName":"h2"},{"title":"SparseDictionary​","type":1,"pageTitle":"Structural Datatypes","url":"/Pack/docs/Datatypes/Structures#sparsedictionary","content":" Pack.SparseDictionary(optionalFormat: { [any]: Datatype&lt;any&gt; }, requiredFormat: { [any]: Datatype&lt;any&gt; })   A Pack SparseDictionary refers to a table with predefined keys, each of which are optional. The second argument is for requried keys, which functions like a regular Dictionary. SparseDictionaries have the overhead of a BitField for all optional keys.  Pack:DefineSchema(Pack.SparseDictionary({ -- Optional keys CFrame = Pack.CFrame, Velocity = Pack.Vector3, -- Do not do: opt = Pack.Nullable(Pack.CFrame) -- All keys in the optional table are already nullable }))   ","version":"Next","tagName":"h2"},{"title":"Union​","type":1,"pageTitle":"Structural Datatypes","url":"/Pack/docs/Datatypes/Structures#union","content":" Pack.Union(...: Datatype)   The Union datatype indicates a value may be one of many datatypes. The order of the values is the order they will be evaluated. The overhead is adaptive and uses the bitbuffer. ","version":"Next","tagName":"h2"},{"title":"Installation","type":0,"sectionRef":"#","url":"/Pack/docs/Installation","content":"","keywords":"","version":"Next"},{"title":"Wally​","type":1,"pageTitle":"Installation","url":"/Pack/docs/Installation#wally","content":" Get the latest version of Pack from wally.run and add it to your wally.toml  For best results, you will need to run wally-package-types for the needed internal types to be exported. Without doing this, you will not have access to the Pack.Schema type needed to use tuple schemas.  ","version":"Next","tagName":"h2"},{"title":"Manual​","type":1,"pageTitle":"Installation","url":"/Pack/docs/Installation#manual","content":" Download the latest version of Pack from releases and insert it somewhere in ReplicatedStorage. ","version":"Next","tagName":"h2"},{"title":"Welcome to Pack","type":0,"sectionRef":"#","url":"/Pack/docs/intro","content":"Welcome to Pack TODO","keywords":"","version":"Next"},{"title":"Packets","type":0,"sectionRef":"#","url":"/Pack/docs/Packets","content":"Packets Pack uses schemas to create packets, and understanding how these work can help design effective schemas. A packet has two parts, the Buffer and the Bit-Buffer. Most datatypes write to the Buffer in sequential order. The Buffer writes in bytes, left to right, and the BitBuffer writes in bits, right to left, and is appended onto the end of the Buffer when the Packet is finalized. Because Pack uses a BitBuffer, the largest amount of unused data in a Packet can be at most 7 bits. Packets themselves are just buffers, and can be passed around as needed before being read with a compatible Schema. You can use JsonEncode and JsonDecode to serialize and deserialize the Packet into a string format. This also has the benefit of applying Zstd compression before encoding in base64. WIP.","keywords":"","version":"Next"},{"title":"Primitive Datatypes","type":0,"sectionRef":"#","url":"/Pack/docs/Datatypes/Primitives","content":"","keywords":"","version":"Next"},{"title":"Any​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#any","content":" Pack.Any   The Any datatype attempts to automatically encode any value inserted, at the cost of a much higher overhead. Currently, Any has few optimizations for tables, treating them all as arrays of any when possible (1 byte overhead for each value), otherwise falling back to a map of [any]: any (2 bytes of overhead for each key-value pair) and does not support metatables or functions.  ","version":"Next","tagName":"h2"},{"title":"BitField​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#bitfield","content":" Pack.BitField(length: number)   A BitField is a highly compressed array of booleans, utilizing the packet bitbuffer to fix 8 booleans worth of data per byte. To use this datatype, you must pass in a fixed length of how many booleans it is expected to store. When writing to this datatype, it is in the format of an array of booleans. If the array is shorter than the expected length, the last values will be treated as false. Reading it will return the array of booleans in the same order.  ","version":"Next","tagName":"h2"},{"title":"Boolean​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#boolean","content":" Pack.Boolean   Encodes a true/false value into a single byte.  ","version":"Next","tagName":"h2"},{"title":"BrickColor​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#brickcolor","content":" Pack.BrickColor   Encodes a BrickColor value in 2 bytes.  ","version":"Next","tagName":"h2"},{"title":"BufferFixed​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#bufferfixed","content":" Pack.BufferFixed(bytes: number)   BufferFixed refers a fixed length buffer, where a buffer of a known length will encoded with zero overhead. The fixed length of the buffer in bytes must be passed in.  ","version":"Next","tagName":"h2"},{"title":"Buffer8​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#buffer8","content":" Pack.Buffer8   Encodes a buffer of variable length between 0 and 255 bytes with 1 byte of overhead.  ","version":"Next","tagName":"h2"},{"title":"Buffer16​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#buffer16","content":" Pack.Buffer16   Encodes a buffer of variable length between 0 and 65,535 bytes with 2 bytes of overhead.  ","version":"Next","tagName":"h2"},{"title":"Buffer24​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#buffer24","content":" Pack.Buffer24   Encodes a buffer of variable length between 0 and 16 MiB with 3 bytes of overhead.  ","version":"Next","tagName":"h2"},{"title":"Buffer32​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#buffer32","content":" Pack.Buffer32   Encodes a buffer of any length with 4 bytes of overhead. The maximum length with a buffer32 is greater than the 1 GiB size limit of buffers.  ","version":"Next","tagName":"h2"},{"title":"CFrame​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#cframe","content":" Pack.CFrame   Encodes a CFrame as either 13 or 19 bytes. A standard Vector3 is used for position. Axis-Aligned CFrames are 13 bytes, otherwise for random orientation CFrames they are encoded in 19 bytes using a Quaternion for rotation, with an average precision of 0.00461° (more than enough).  ","version":"Next","tagName":"h2"},{"title":"Color3​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#color3","content":" Pack.Color3   Encodes a Color3 value as standard 24-bit RGB in 3 bytes.  note The Color3 Datatype actually uses 32 bit floats to store RGB, meaning sometimes colors will have RGB values above 255. If this is necessary, use Color3float32 instead  ","version":"Next","tagName":"h2"},{"title":"Color3float32​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#color3float32","content":" Pack.Color3float32   Enodes a Color3 value in full using 12 bytes. This is for when you have colors with RGB values above 255.  ","version":"Next","tagName":"h2"},{"title":"ColorSequence​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#colorsequence","content":" Pack.ColorSequence(type: Datatype&lt;Color3&gt;)   Encodes a ColorSequence using a Color3 datatype to encode the value of each ColorSequenceKeypoint.  ","version":"Next","tagName":"h2"},{"title":"DateTime​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#datetime","content":" Pack.DateTime   Encodes a DateTime with millisecond precision using 8 bytes.  ","version":"Next","tagName":"h2"},{"title":"EnumItem​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#enumitem","content":" Pack.EnumItem(enum: Enum)   Encodes an EnumItem from a provided Roblox Enum using between 1 and 2 bytes. Some common Enums such as Material and KeyCode use 2 bytes due to how these Enums were set up (they have items with values going past 255)  ","version":"Next","tagName":"h2"},{"title":"Float16​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#float16","content":" Pack.Float16   Encodes a 16-bit floating point number using 2 bytes  Range:  Subnormal: ±6.1×10-5Normal: ±6.5×104Precision: ~3.3 decimal places  ","version":"Next","tagName":"h2"},{"title":"Float24​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#float24","content":" Pack.Float24   Encodes a 24-bit floating point number using 3 bytes  Range:  Subnormal: ±1×10-19Normal: ±2×1019Precision: ~5.9 decimal places  ","version":"Next","tagName":"h2"},{"title":"Float32​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#float32","content":" Aliases Float is an alias for Float32 and can be used instead  Pack.Float32 Pack.Float   Encodes a 32-bit floating point number using 4 bytes  Range:  Subnormal: ±1.2×10-38Normal: ±3.4×1038Precision: ~7.2 decimal places  ","version":"Next","tagName":"h2"},{"title":"Float64​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#float64","content":" Aliases Double is an alias for Float64 and can be used instead  Pack.Float64 Pack.Double   Enocdes a 64-bit floating point number using 8 bytes. This is the type used by lua numbers. It is also the only numeric type that can be used for UserIds, as those have passed the 32-bit unsigned integer limit.  Range:  Subnormal: ±2.2×10-308Normal: ±1.8×10308Precision: ~15.9 decimal places  ","version":"Next","tagName":"h2"},{"title":"Fraction​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#fraction","content":" Aliases Frac is an alias for Fraction and can be used instead  Pack.Fraction   Encodes a proper fraction (positive real number between 0 and 1) with a fixed precision of 1/216 (0.00001525878).  ","version":"Next","tagName":"h2"},{"title":"Instance​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#instance","content":" Pack.Instance   Encodes a reference to an Instance. This will place a UID tag on the instance so it can be located later. This UID is 4 bytes. Note that the UID tag is not removed, as  warning This reference does not persist between server and client WRITE UNSAFE Writing a reference to an Instance that does not already have a UID will synchronize the thread  In saving places, references persist between server runtimes.  ","version":"Next","tagName":"h2"},{"title":"Int8​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#int8","content":" Aliases Byte is an alias for Int8 and can be used instead  Pack.Int8 Pack.Byte   Enocdes an 8-bit signed integer in a single byte. Range: -128 – +127  ","version":"Next","tagName":"h2"},{"title":"Int16​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#int16","content":" Aliases Short is an alias for Int16 and can be used instead  Pack.Int16 Pack.Short   Encodes a 16-bit signed integer in 2 bytes. Range: -32,768 – +32,767  ","version":"Next","tagName":"h2"},{"title":"Int32​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#int32","content":" Aliases Int is an alias for Int32 and can be used instead  Pack.Int32 Pack.Int   Encodes a 32-bit signed integer in 4 bytes. Range: -2,147,483,648 – +2,147,483,647  ","version":"Next","tagName":"h2"},{"title":"Int64​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#int64","content":" Aliases Long is an alias for Int64 and can be used instead  Pack.Int64 Pack.Long   Encodes a 64-bit signed integer using 8 bytes.  This datatype is implemented using two 32-bit segments due to Luau's number type limitations, which only supports exact representation up to 253 − 1. The value is split into a low and high 32-bit integer in little-endian order (low first, then high), and recombined on read.  Range (exact): −9,007,199,254,740,991 – +9,007,199,254,740,991  Values beyond this safe range lose precision due to the limitations of Luau’s number type (IEEE 754 double). Use only for integers within ±253 for guaranteed correctness. See Wikipedia for how Doubles lose integer precision.  Int64 values used in the Roblox ecosystem, such as AssetIds and UserIds take Luau's number limitations into account, so Int64 and UInt64 can be used to store these.  ","version":"Next","tagName":"h2"},{"title":"Literal​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#literal","content":" Pack.Literal(value: any)   Holds a literal value without any overhead. This is useful in tuples.  ","version":"Next","tagName":"h2"},{"title":"Null​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#null","content":" Pack.Null   Represents nothing, directly uses zero bytes. For use in the Union structure  ","version":"Next","tagName":"h2"},{"title":"NumberSequence​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#numbersequence","content":" Pack.NumberSequence(type: Datatype&lt;number&gt;)   Encodes a NumberSequence using the provided numeric datatype to store the value of each NumberSequenceKeypoint  ","version":"Next","tagName":"h2"},{"title":"Object​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#object","content":" Pack.Object(metatable: any, data: any)   Allows marshalling a lua object by providing the class's metatable, and a Dictionary of members to serialize from the object. This should work for most common OOP patterns. An example has been provided for the classic lua OOP paradigm.  -- Example Class -- local exampleClass = {} exampleClass.__index = exampleClass function exampleClass:SomeMethod(val: number) self.someProperty = val end function exampleClass.new(val: number) local self = setmetatable({}, exampleClass) self.someProperty = val return self end ---- -- Create a schema to marshall exampleClass by providing its metatable -- as well as instructions to serialize its properties local schema = Pack:DefineSchema(Pack.object(getmetatable(exampleClass), Pack.Dictionary({ someProperty = Pack.Double }))) ---- -- Test it with an object of exampleClass local exampleObject = exampleClass.new(1) print(exampleObject.someProperty) -- &gt;&gt;&gt; 1 exampleObject:SomeMethod(10) print(exampleObject.someProperty) -- &gt;&gt;&gt; 10 local reconstructedObject = schema:Read(schema:Write(exampleObject)) print(reconstructedObject.someProperty) -- &gt;&gt;&gt; 10 reconstructedObject:SomeMethod(100) print(reconstructedObject.someProperty) -- &gt;&gt;&gt; 100   ","version":"Next","tagName":"h2"},{"title":"Region3​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#region3","content":" Pack.Region3   Encodes a Region3 as a min and max Vector3, giving a total of 24 bytes.  ","version":"Next","tagName":"h2"},{"title":"Region3int16​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#region3int16","content":" Pack.Region3int16   Encodes a Region3int16 as a min and max Vector3int16, giving a total of 12 bytes.  ","version":"Next","tagName":"h2"},{"title":"StringFixed​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#stringfixed","content":" Pack.StringFixed(bytes: number)   StringFixed refers a fixed length string, where a string of a known length will encoded with zero overhead. The fixed length of the string in bytes must be passed in. (One character can take 1 to 4 bytes)  ","version":"Next","tagName":"h2"},{"title":"String8​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#string8","content":" Pack.String8   Encodes a string of variable length between 0 and 255 bytes with 1 byte of overhead. Chars already have a variable length of 1-4, so this can range from 255 chars to 63 chars.  ","version":"Next","tagName":"h2"},{"title":"String16​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#string16","content":" Pack.String16   Encodes a string of variable length between 0 and 65,535 bytes with 2 bytes of overhead. Chars already have a variable length of 1-4, so this can range from 65,535 chars to 16,383 chars.  ","version":"Next","tagName":"h2"},{"title":"String24​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#string24","content":" Pack.String24   Encodes a string of variable length between 0 and 16 MiB with 3 bytes of overhead.  ","version":"Next","tagName":"h2"},{"title":"String32​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#string32","content":" Pack.String32   Encodes a string of any length with 4 bytes of overhead. The maximum length with a string32 is bigger than the 1 GiB size limit of buffers.  ","version":"Next","tagName":"h2"},{"title":"UDim​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#udim","content":" Pack.UDim   Encodes a single UDim as 6 bytes. We assume the offset will be within the range of a int16. If this is not the case, you will have to send the UDim as a float32 scale and int32 offset.  ","version":"Next","tagName":"h2"},{"title":"UDim2​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#udim2","content":" Pack.UDim2   Encodes a UDim2 as 12 bytes. We assume the offset will be within the range of a int16. If this is not the case, you will have to send the two UDims as a float32 scale and int32 offset.  ","version":"Next","tagName":"h2"},{"title":"UInt8​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#uint8","content":" Aliases UByte is an alias for UInt8 and can be used instead  Pack.UInt8 Pack.UByte   Enocdes an 8-bit unsigned integer in a single byte. Range: [0–255]  ","version":"Next","tagName":"h2"},{"title":"UInt16​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#uint16","content":" Aliases UShort is an alias for UInt16 and can be used instead  Pack.UInt16 Pack.UShort   Encodes a 16-bit unsigned integer in 2 bytes. Range: [0–65,565]  ","version":"Next","tagName":"h2"},{"title":"UInt32​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#uint32","content":" Aliases UInt is an alias for UInt32 and can be used instead  Pack.UInt32 Pack.UInt   Encodes a 32-bit unsigned integer in 4 bytes. Range: [0–4,294,967,295]  ","version":"Next","tagName":"h2"},{"title":"UInt64​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#uint64","content":" Aliases ULong is an alias for UInt56 and can be used instead  Pack.UInt64 Pack.ULong   Encodes a 64-bit unsigned integer using 8 bytes.  Like Int64, this is encoded by splitting the number into low and high 32-bit unsigned segments in little-endian order (low first, then high), and combining them when reading. Range (exact): [0–9,007,199,254,740,992]  Although UInt64 can store exact integers up to 253, Luau numbers lose precision above 253. Refer to Int64 for more info.  ","version":"Next","tagName":"h2"},{"title":"Vector2​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#vector2","content":" Pack.Vector2 -- Uses Float32 by default (8 bytes total) Pack.Vector2(Pack.Float24) -- Can be called with any other numeric datatype   Encodes a 2D vector of any numeric datatype.  Vector2 uses a Float32 when not provided another datatype, which is consistent with Luau vectors (Making a Vector2 with Float64s will not increase precision). see Float32 for approximate range and precision of each component.  ","version":"Next","tagName":"h2"},{"title":"Vector2int16​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#vector2int16","content":" Pack.Vector2int16   Encodes a 2D vector of int16s using 4 bytes.  ","version":"Next","tagName":"h2"},{"title":"Vector3​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#vector3","content":" Pack.Vector3 -- Uses Float32 by default (12 bytes total) Pack.Vector3(Pack.Float24) -- Can be called with any other numeric datatype   Encodes a 3D vector of any numeric datatype.  Vector3 uses a Float32 when not provided another datatype, which is consistent with Luau vectors (Making a Vector3 with Float64s will not increase precision). see Float32 for approximate range and precision of each component.  note Compatible with the Roblox Vector3 library and luau vector library. Will return as a luau vector, but these are interchangeable with the Vector3 library. (Vector3 methods can be used on vectors and vector library functions can take Vector3s)  ","version":"Next","tagName":"h2"},{"title":"Vector3int16​","type":1,"pageTitle":"Primitive Datatypes","url":"/Pack/docs/Datatypes/Primitives#vector3int16","content":" Pack.Vector3int16   Encodes a 3D vector of int16s with 6 bytes.  note You should try to avoid using the Vector3int16 datatype in general, as it is much slower than Vector3. ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}